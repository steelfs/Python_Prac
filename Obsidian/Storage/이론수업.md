using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _01_Console
{
    class 이론수업
    {

        /*5월 18일
         * 가장 먼저 해야할 것. 1. 게임 사전기획  : 무엇을 만들지 구체화, 정확하게 머릿속에있는 그림을 다른사람에게 전달하기 위함. 만약 팀프로젝트라면 의견조율 필요

         * 2. 분석 : 이게 맞나? 최선인가? // 시장상황 유사 출시 게임작 시장점유율 등을 고려해야함., 차별점 유사한 시장에 존재하는게임 중 굳이 내가만든 게임을 해야하는 이유가 있는가?
                     현실적인 문제로 상업적인 가치가 있는가? 결국 게임을 만드는 이유는 돈을 벌기 위함. 회사입장에서 고려해야할것 임금, 엔진 로열티, 
           3. 평가 :  디테일한 객관적 평가 
           4. 발전 : 아이디어를 강화하고 발전시키기 : DLC, 
           5. 최종결정 : 

         *  DLC mode 추가
         * @@ reverse 접근방식 : 문제점이 있는 곳을 먼저 찾는다.
         * 
         * 기획
         * - 무엇을 만들것인가 -> 아이디어의 발상
         * 영감 - 번뜩이는 아이디어 
         * 브레인스토밍 기법 : 우선 아이디어를 생각나는대로 쏟아내고, 꺼내고본다, 이 단계에서는 태클금지
         * 
         *  공명 : 아이디어를 정리하고 합친다. 시너지 작용이 일어날수 있는 경우의 수를 파악한다.
         * 
         * 수렴 :불필요한 곁가지 아이디어를 쳐낸다. (한줄로, 가능하면 짧게 정리가능해야한다.)
         * 
         * 
         * 5월 19일 ------------------
         * 분석 : 시장분석, 사용자, 경쟁자 (어디서, 어느시장에서 무엇을 할 것인가)
         * 시장분석  - 게임시장의 특징 : 온라인마켓 위주의 유통구조, 아이디어기반의 창조가 비교적 자유롭다. 
         *            사회적 분위기 확인 , 정책 및 법률 (ex 셧다운제) 개인의 사적으로 선을 넘는 행위는 비교적 관대하나, 집단, 회사 의 선을 넘는 행위는 그렇지 못하다.
         *  
         *  사용자 - 타겟층 분석 : 나이, 성별, 직업군 직장인target의 방치형 게임, 대체적으로 남자 -액션류, 여자- 키우기 
         *  
         *  경쟁자분석 - 상대방의 장단점 분석, 장점을copy하고 단점을 보완한다
         *  정보획득 - 직접 플레이  or 검증 필요 or 신뢰성있는 공식자료 // 
         *  중요한 정보의 판별 (KPI Key Perfomence indicator) 게임백서
         *       
         *       
         *       
         *  5월 22일 (월)----------------------------
         *  KPI - 게임의 성공여부를 판단하는데 사용되는 지표
         *  감정과 감성을 배제한 냉정하고 객관적 평가. 불가피하게 숫자로 판단할 수 밖에 없다.
         *  
         *  매출, 다운로드 횟수, DAU, MAU, 전환률
         *  
         *  
         *  비즈니스 모델
         *  ex) 오락실, 패키지 구매, 월정액, 부분무료화 free to Play, 확장팩 발매, DLC,
         *        
         *  
         *  다운로드 횟수/ free to Play 유료컨텐츠를 일부 맛을 보게 한 다음 현질유도  / 전환율 = 전체 플레이 유저 / 실제 비용을 지불한 경우 ; 
         *  어쩔수없이 적절한 현질유도가 필요하다.
         *  
         *  DAU, MAU 
         *  
         *  -매출이 커질수록 순이익률이 올라갈 확률도 높아진다. 순이익 
         *  
         *  게임회사 - 대부분 영세하다. 구조적으로 투자자를 끼고 가는 경우가 많다. 투자자의 입김이 많이 작용하면 때때로 방향성이 어긋나는 경우가 있다.
         *  투자자는 대체적으로 보수적이다.
         *  
         *  
         *  5월 23일 (화)---------------------------------------------------------
         *  평가 
         *  게임 기본 구성요소
         *  스토리, 캐릭터
         *  포괄적인 개념으로 메커니즘 : 규칙
         *  미적요소 : 그래픽, 사운드, 스토리 케릭터    
         *  기술 : 몰입이 깨지는 순간 재미가 없다고 느끼게 된다. 가장 몰입을 깨는순간 - 버그로인해 서버가 터졌을때   프로그래머와 그래픽디자이너의 목적이 상충할 때가 종종 있다.
         *  게임공간 : 맵 , 기획자입장에서 오픈월드게임을 만들때 가장 힘든것 유기적으로 스토리를 연결하는것. 유저가 어디로 갈지 모르기 때문.  좋은예로 젤다가 있다.
         *  차별화요소 : 굳이 이 게임을 해야할 이유,   포지셔닝이 이미 잘 되어있는 경우, 그래픽 , 사운드
         *  게임 재미요소 : 성취감 - 적절한 허들, 보상 제공 : 현실과 대비되는 점이고, 게임이 재밌는 이유이다. 불확실성도 여기에 포함된다.
         *                 욕구충족 - 매슬로우  심리적욕구, 안전의 욕구, 사회적 욕구 - 길드, 커뮤니티, 동호회,    존경의 욕구 - 랭킹 시스템, 자아실현 - 자신만의 목표
         *                 자극적인 요소 : 평소에 하지 못하는 것들
         *                 감정 이입 :
         *                 의미있는 선택 제공(리스크에 따른 선택) : 선택에 따른 다른 스토리 전개 
         *                  단계적 매몰비용 발생시키기
         *  5월 24일 수 -----------------------------------------------------------------------
         *  보상. 100%만족감을 주면 흥미를 잃게 된다. 주기적으로 갈증을 느끼게 만드는 구조가 회사입장에선 불가피하다.
         *  경쟁사에서 내가 생각하는 차별화 요소를 제공하는가?  사용할때, 하지 않을때 그 이유를 분석
         *  실현가능성
         *  게임 세션 길이 - 게임 을 플레이할 때 한판의 길이, 스테이지 단위, 사람의 집중력은 한계가 있다. 뇌가 refresh 하는 시간
         *  
         *  레벨디자인 - 맵을 어떨게 꾸밀 것인가?  ,오브젝트, NPC등의 위치를 유기적으로 배치해야한다.
         *              선형구조(고전적 방식 ), 평면구조(오픈월드 방식)
         *              
         *  자원 - 경제시스템, 화폐(경화 hard currency 조절가능 cash, 연화softCurrency 제작자 입장에서 Control 불가능 유저가 원하는 만큼 획득할 수 있다.
         *                                                          인플레 가능성 존재 - 돈을 소비하게끔 만드는 시스템이 필요
         *         아이템
         *         자원은 병목구간이 필요하다. - 자원이 부족해지는 구간이 필요하다. (현질유도)
         *         
         *  벨런스 - 대칭구조(벨런스 적으로는 가장 완벽하지만 게임이 변수가 없고, 뻔하고, 단조로워진다.)
         *           비대칭적으로 하면서 밸런스를 맞추기란 쉬운일 이 아니다.
         *        -  우월전략을 발생시키면 안된다. (무조건 유리한 전략) 항상 같은패턴이 반복되게 된다.
         *        - 학습곡선을 고려해야한다. 게임을 배우는데 어려워선 안된다.  배우기는 쉽고 마스터하기는 어렵게 만들어야한다.
         *        
         *  비즈니스모델 - 돈을 버는 방법. 어떻게 수익을 창출할 것인가. 대표적모텔 free to play 부분 유료화, 패키지, DLC, 가챠, P2E play to earn(NFT),
         *  
         *  실현가능성
         *  - 기술적 : 게임내 기능을 실제로 구현 가능한가?
         *  - 상업적 : 게임 발매로 수익을 낼 수 있는가
         *  
         *  아이디어 강화 및 발전
         *  -극적 효과 강화 : 줄거리, 스토리, 주제, 테마, 매력적인 그래픽, 캐릭터, 배경,  감성을 자극하는 부분
         *  
         *  최종결정 및 정리
         *  - 소프트웨어 개발 모델     waterFall 방식 문제점 : 이전 작업에 수정할 것이 생기면 처음부터 갈아엎어야한다.
         *                           나선형 모델 (점진적 모델) :구현, 평가 반복 
         *                           프로토타이핑 모델 : 핵심기능만 구현을 해서 테스트 해본다
         *      
         *  - 문서화 
         *  
         *  
         *  5월 29일 --------------------------------------------------------------
         *  
         *  평가
         *  게임시장은 어떤 특성을 갖고있는가
         *  
         *  1-2 게임흥행여부를 판단하기 위한 KPI를 하나이상 나열하시오
         *      매출,순이익, DAU, MAU전환율
         *      
         *  2-1 게임산업에대한 공식적이고 객관적 정보를 얻기에 적합한 기관은?
         *  통계청, 한국콘텐츠 진흥원
         *  
         *  2-2 게임디자인시 고려할 인구통계 변인에는 어떤 것들이 있는가
         *  나이, 성별, 직업군,
         *  
         *  3-1 게임을 구성하는 네가지 기본요소는 무엇인가
         *  -메커니즘, 기술, 미적요소, 스토리, 게임공간
         *  
         *  3-2 게임이 제공하는 재미요소에는 어떤것들이 있는가
         *  욕구충족,몰입, 감정이입, 성취감 등
         *  
         *  4-1 많은 수의 아이디어를 쉽게 구상하기 위한 방법중 하나로 최대한 자유롭게 의견을 제ㅣ하는 것을 가장중요시 여기는 학습도구, 기법이 무엇인가
         *      브레인스토밍
         *  
         *  4-2 창조적발상을 위한 네가지 단계는 어떻게 되는가
         *      영감 - 종합 - 공명 - 수렴 
         *      
         *  5-1 플레이어의 게임숙련도를 학습량, 학습시간, 반응시간 정밀도등을 측도로 그래프로 나타낸것은?
         *      학습곡선
         *      
         *  5-2 게임 내 PVP 밸런스를 잡는방법 중 가장 쉬운방법은 무엇인가?
         *      -대칭이 되도록 양쪽을 똑같이 만든다.
         *  (Ran Ability) 비대칭
         *  
         *  6-1 여러아이디어의 각 요소와 부분을 적절히 배합해서 새로운 아이디어를 만들어내는 것을 무엇이라고 하는가
         *  합성, 공명
         *  
         *  6-2 게임의 극적 요소를 강화하기 위한 요소들에는 어떤 것들이 있는가
         *  장르 줄거리, 스토리, 그래픽
         *  
         *  
         *  
         *  
         *  
         *  
         *  6월 7일 평가 예정
         *  
         *  게임 컨셉기획
         *  
         *  장르 
         *  - 예술적 부분에서 작품을 구분할 때 느슨한, 분류 범위 / 들었을때 확실치는 않지만 대략적으로 유추가능한 범위 
         *  
         *  게임장르
         *  - 초기 : 하드웨어 스펙이 저렴했을 때는 제한적이었다.  액션, 퍼즐, 어드벤처, RPG, 전략
         *  
         *  - 이후 : 액션RPG, 대전액션 등 장르의 조합, 합성이 가능해졌다. 
         * 
         *  
         *  액션, 대전 조합의 스트리트파이터 커맨드 입력방식으로 히트를 쳤었다.
         *  
         *  RPG, Table RPG - 던전앤드래곤
         *  RPG 의 핵심은 플레이어의 성장이다.
         *  
         *  5월 30일 -----------------------------------------------------------------------
         *  
         *  게임의 주제, theme
         *  - 게임 디자인에서 게임의 메시지를 전달하기 위한 일정한 방향성을 이끌어내는 핵심요소, 전달하고싶은 말, 이야기, 스토리, 정체성
         *  - 플레이어가 자연스럽게 공감할 수 있도록 전달. 공감이 안되면 몰입이 깨지고, 왜 플레이를 해야하는지에 대한 의문이 들 수 밖에 없다.
         *  - 보편성 - 대체적으로 대중들은 비슷한 생각을 갖고있다., 일관성 - 어떤 이야기를 하고싶은 것인가, 의미, 흥미 등등...
         *  
         *  이야기(스토리)
         *  - 게임 스토리텔링의 가장 큰 특징. - 플레이어의 선택에 의해 게임의 내용이 변하는 상호작용. 인터렉티브하다.
         *  - 시나리오 : 과정중 상황이 바뀔 수 있기 때문에 처음부터 완벽하게 시나리오를 짤 수는 없다 
         *              => 시놉시스 : 전체적인 줄거리와 윤곽, 주제, 기획의도, 줄거리, 등장인물 등이 포함되어야 함 . 왜 이렇게 해야하는지 짧게 요약해야함. 투자유치를 위해 중요하다.
         *  
         *  시놉시스 이후 스토리보드 (3-1)
         *   - 이야기의 구성요소, 촬영정보, 동선등을 간략하게 장면별로 스케치한것
         *   
         *   서사
         *   - 이벤트를 순서대로 잘 전달하는 것.
         *    오픈월드형식에서는 쉽지 않다.
         *    플레이어 유도(간접통제) - 
         *    자의에 의한 선택이라고 느끼되 자연스러운 선택을 따라 스토리가 진행될 수 있도록 오브젝트를 배치 또는 BGM 변경 등으로
         *    
         *  
         *  5월 31일 -------------------------------------------------------------------------------
         *  
         *  캐릭터 
         *  - 캐릭터 수집형, 고유한 매력
         *    - 능력치
         *    - 외형
         *    - 캐릭터간 관계
         *    - 역할 - 악역, 중간보스 , 최종보스, 스승, 제자
         *    
         *    PC - playable character  
         *        아바타, 사용자의 분신
         *        커스터마이징 : 플레이어가 원하는 개성을 가질 수 있도록 외형을 변경하는 기능을 제공 - 플레이어의 몰입을 강화할 수 있다.
         *        불쾌한 골짜기?
         *        
         *    NPC - Non playable character - 
         *          플레이어를 제외한 모든 케릭터
         *          정보제공(스토리 전개, 튜토리얼, 조작방식), 컨텐츠 제공( 전투, 보상, 미니게임)
         *          
         *          적, 동료
         *          동료
         *          - 두번째 PlayableCharacter
         *          - 전투 보조 상호보완적으로 능력치 설계
         *          - 피보호자
         *          - 스토리 설명 
         *          플레이어는 사용자와 지식수준이 비슷할수록 감정이입에 원활하다. 
         *          
         *          
         *          적의 역할
         *          - 플레이어와 싸우는 대상
         *          - 싸우는 이유 - 전투 자체가 재밌을 경우, 게임의 진행, 성장, 보상, 죽이고싶은 적의 도발
         *          - 적과의 드라마 -> 인상깊은 적을 만들 수 있다. 빌드업과정이 너무 길면 인내심의 한계치를 넘어 게임을 접어버린다.        
         *  6월 1일 --------------------------------------------------------------------------
         *  Git hub
         *      
         *  6월 2일 --------------------------------------------------------------------------------------------------------------
         *  배경
         *      구성요소 : 미적 요소 (시대적 배경, 문화적 배경, 스토리, 음향(앞으로 일어날 이벤트를 미리 암시할수 있게 해준다))
         *      
         *      컨셉아트 : 게임을 만들기 전 머릿속에 있는 것을 타인에게 정확하게 전달하기 위해 시각화 한것. 컨텐츠의 아이디어 전개와 상황 연출을 보여주는것
         *      세계관 : 작품의 시공간적 배경 
         *      음향의 역할 : 주제 강조, 주변환경의 디테일 표현, 힌트 제공
         *      
         *      
         *  기술
         *      기술적 요소가 중요한 이유
         *      -기술이 부족할 경우 구상중인 컨셉을 제대로 원활하게 전달할 수 없다
         *      
         *  미리 만들어보기
         *      -프로토타입핑 : 게임을 실제로 제작하기 전에 정말 기능적으로 구현이 가능한지, 기술 실증과 재미를 확인하기 위한 핵심요소만 먼저 만드는 작업
         *      -그레이박스 레벨디자인 : 게임에서 실제사용할 아트워크를 만들기 전에 레벨 안에서의 크기와 레이아웃을 확이낳기 위해 회색의 상자로 대략적인 크기만 맞춰 작성하는 레벨디자인
         *      
         *  시점
         *      3인칭 : 제 3자 입장에서 플레이어를 살펴보는 카메라 시점 사이드뷰, 탑뷰, 쿼터뷰 등등
         *      1인칭 : 플레이어의 시점과 사용자의 시점을 일치시킨 카메라 시점
         *          
         *          
         *          
         *  6월 8일 ---------------------------------------------------------------------------------------------------------------
         *  게임 알고리즘(문제를 하결하는 방법)
         *      (디자인패턴)모범답안 보다 좀더 정답에 가까운 기준, 해결하기 위한 절차를 순서대로 설명한것 : 최대한 간결하게 필요한 내용만
         *      
         *      - 좌표계 - 위치를 표현하기 위한 시스템, 데카르트 좌표계
         *      
         *      좌표계를 표현하는 방법 - 왼손좌표계, 오른손좌표계(수학계에서 일반적으로 사용됨)
         *      
         *      왼손좌표계  (Window, Maya) - 오른쪽 : +x // 위쪽 +y // 앞쪽 +z
         *      
         *      
         *      오른손좌표계(OpenGL, 3D Max) 오른쪽 +x // 위쪽 +y // 뒤쪽 +z
         *      
         *      
         *      로컬좌표계 : 오브젝트의 원점을 기준으로 한 좌표계
         *      
         *      월드좌표 : 월드의 원점을 기준으로 한 좌표계
         *      
         *      월드변환(World Transform)
         *  
         *  6월 9일 ---------------------------------------------------------------------------------------------------
         *  
         *  월드변환(World Transform)
         *      오브젝트가 있다고 가정 - 저장된 데이터 : 구성하고있는 점들의 좌표, 그리는 순서, 겹쳐지는 점들의 번호 , 로컬좌표를 월드좌표로 변환하는 작업
         *      위 이련의 과정들은 계산량을 줄이기 위한 과정이다.
         *  
         *      스크린좌표계
         *      픽셀위 위치를 나타내기위한 좌표계, 원점기준,
         *      
         *      좌표계 - 원점과 축의 방향이 어떻게 진행되는가?
         *      
         *  벡터(Vector) - 방향과 크기 
         *      * 내적 - 두 벡터간 사이각구할때 사용, 외적 - 
         *  
         *  행렬(Matrix)
         *      트렌스폼(위치, 회전, 크기 변화)를 하나의 행렬로 표현가능
         *      행렬을 곱하는 것으로 변화를 누적시킬 수 있다.
         *      변화의 순서에 따라 결과값이 달라지기때문에  적용가능
         *      
         *  쿼터니언(Quaternion)
         *      회전을 기록하는 방식
         *      오일러앵글의 짐벌락 현상을 해결하기 위해 등장
         *      더 적은 메모리 요구와 거 적은 연산이 가능하다
         *      
         *  충돌처리 - 오브젝트의 원점의 
         *      콜라이더가 없을 경우 오브젝트를 기준으로 처리할경우 연산량이 너무 많아진다.
         *      
         *      
         *      
         *      랜더링 파이프라인
         *      - 3D 월드를 2D래스터 이미지로 변경하는 작업
         *      
         *      DX9 기준 
         *      1. 로컬 변환
         *      2. 월드 변환 - 저장된 로컬의 점들을 월드좌표로 옮긴다.
         *      3. 카메라변환 : 눈에 보여지는 부분만 랜더링 하기때문에 카메라변환을 한다.
         *      
         *      2D, 3D의 가장 큰 차이점 - 원근감  
         *      카메라의 시야 near Far 조정가능
         *      
         *      4. 프로젝션(투영변환)
         *      5.레스터라이즈rasterize 최종적으로 이미지를 만드는 작업
         *      
         *      위 다섯가지 과정 1~5까지 1프레임
         *      
         *  메모리할당
         *      운영체제에 요청해서 받아와야한다.
         *      느리다. 운영체제를 거친다. 필요한 만큼의 빈공간이 있는지 찾아야한다. -> 다른프로그램이 해당 메모리공간을 못쓰도록 Lock 해야한다.
         *      
         *  메모리풀(Memory Pool)
         *      게임전체적으로 사용될것으로 예상되는 최대 메모리량을 한번에 할당받는다.
         *      메모리할당이 필요하면 이미할당된 Pool에서 꺼내옴 필요없어지면 Pool로 되돌려보냄
         *      객체를 생성할때 급격한 프레임드롭이 없어지고 메모리 파편화(메모리 공간의 낭비)를 막을 수 있다.
         *      
         *  오브젝트 풀(Object Pool)
         *      게임에서 한번에 사용될 최대 오브젝트 갯수만큼 오브젝트를 미리 생성해서 풀을 만든다.
         *      생성된 오브젝트는 모두 비활성화시킨다.
         *      필요할 때 풀에서 꺼내온 후 활성화 시켜준다.
         *      사용후 비활성화 후 풀로 반환한다.
         *      
         *  자료구조(어렵다는 선입견이 있다)
         *      데이터를 (어떻게) 저장하는 방법 (편하게 사용하기 위해) 어떤식으로 저장을 해야 빠르고 편하게 쓸수 있는가
         *      
         *      -배열 [] array
         *          같은종류의 데이터를 한번에 여러개 갖고싶을 때 사용 
         *          데이터 사이에 빈공간이 없어야한다.  필요한 주소 == 배열시작주소 + 데이터크기 * 인덱스
         *          장점 : 랜덤 엑세스성능이 매우 뛰어나다 
         *          단점 : 배열 크기 변경작업이 매우 느리다. 삽입, 삭제 //
         *                 데이터사이에 유사시 사용할 수 있는 빈공간이 없어야하기 때문에 new 를 사용해서 새로 만들어야하기 때문에 동적할당이 불가능하다
         *          
         *      리스트(List)
         *          배열의 단점을 커버하기 위해 등장 
         *          노드 (데이터 + 링크) 를 데이터를 저장한다. 시작 노드를 Head, 마지막주소값은 Tail이라고 한다.
         *          장점 : 삽입, 삭제가 매우 빠르다.
         *          단점 : 링크를 통해서 데이터 위치를 찾기 때문에 무조건 순서대로 찾아야해서 랜덤엑세스 접근속도가 매우 느리다.
         *      
         *      
         *      스텍(쌓다)
         *          후입선출(Last in First Out, LIFO), 데이터를 넣을 때 Push, 꺼내올때 Pop,  가장 나중에 추가된 데이터 = Top
         *          어떤 긴급한 상황에서 빠르게 실행해야할때 
         *          함수의 처리방식 - 함수안에서 다른 함수를 호출할 경우 
         *          
         *      큐(Queue)
         *          FIFI(First In First Out 선입선출)
         *          순서대로 처리하기위한 용도   마지막 추가된 부분 : rear // 가장먼저 추가된 부분 Front  .//데이터를 넣을 때 Enqueue// 꺼낼 때 Dequeue
         *          
         *      위 네가지를 포괄한 개념을 선형 자료구조(Linear Data Struct) 라고 한다.
         *      
         *      6월 12일 --------------------------------------------------------------------------------------------------
         *      
         *      비트연산 
         *              & : 둘 다 1 이면 1, 아니면 0
         *              | : 둘 중 하나라도 1이면 1, 아니면 0
         *              
         *              1 1 0 0
         *              1 0 1 0
         *              
         *           &  1 0 0 0
         *           |  1 1 1 0
         *              
         *           & =  bit flag 논리 곱,  할때 사용
         *           | = 논리 합, 추가할 때
         *        
         *        shift 연산
         *      << 왼쪽     1101  << 2  = 110100 , 데이터가 넘칠경우 넘친부분 삭제  //  << 1 = * 2 의 효과와 같아진다
         *      >> 오른쪽   1101  >> 2 = 0011 //   / 2 와 같은 효과
         *      
         *      
         *      Frustum View
         *      카메라 뷰 영역 안쪽만 렌더링 한다.   사각절두체, 카메라가 촬영하는 영역
         *      
         *      
         *      폴리곤, 페이스 - 기본적으로 모든 3D 오브젝트는 삼각형으로 구현된다.
         *      정점 (Vertex) 삼각형을 이루는 점
         *      메시(Mesh) 하나의 모델을 이루는 페이스의 집합. 하나의 모델 오브젝트
         *      엣지(Edge) 정점 사이를 잇는 선
         *      
         *      점의 위치 U, V
         *      
         *      보간(Interpolation, Lerp)
         *          시작값과 마지막 값이 있을 때 시작부터 끝까지 걸리는 시간이 있을 때 중간값을 계산 하는 것 500km 5시간 걸릴 때   2시간을 갔다면 200km 만큼 왔다고 가정할 수 있다.
         *      키프레임 애니메이션의 중간값을 보간으로 처리할때 사용된다.
         *      
         *      애니메이션
         *          키프레임 애니메이션 : 키프레임만 저장하고 나머지 애니메이션 정보는 보간 정보로 만드는 기법
         *          
         *          본(Bone)애니메이션 : 모델링 내부에 보이지않는 뼈를 심는다. 뼈가 움직이면 뼈와 연결된 정점만 움직이는 기법 리깅이라고 부르기도 한다
         *                              각 뼈는 계층적으로 구성되어있다. 상위뼈가 움직이면 하위뼈들도 유기적으로 움직인다. (얼마나 영향을 받을 지 설정된 값만큼)
         *                              
         *          Skinned Mesh : 본애니메이션의 확장 관절부분 같은 곳을 피부가 늘어나는 것 처럼 메시의 형태를 변경해서 관절부위가 벌어진 것처럼 보이지 않게 하는 것
         *          
         *  6월 13일 ---------------------------------------------------------------------------------------------------------
         *     
         *     C# 변수의 유형
         *   
         *     값형식(value)  
         *          변수에 값이 직접저장되는 형식
         *          스텍 메모리에 저장
         *          작지만 빠르게 접근 가능
         *          struct로 만들어진다  대입시 깊은복사  원본과 같은 사본이 만들어진다.
         *          ex(몬스터 오브젝트 생성) 참조형식 사용시 모든 개체가 같은 변화의 영향을 받게 된다
         *          같은 값의 사본을 만들어야하기 때문에 실행속도가 느리다.
         *          
         *     참조형식(referrence)
         *          변수 데이터에 대한 참조가 저장되는형식 
         *          힙 (운영체제가 관리하는 전체 메모리)메모리에 저장 new 연산자 사용할때도 할당
         *          크지만 느리다
         *          Class로 만들어진다
         *          대입시 얕은 복사.
         *          주소만 넘겨주기때문에 실행속도가 빠르다.
         *          
         *      제네릭 - 변수 외 타입도 파라미터로 넘길수 있다
         *      boxing unboxing
         *      힙, 스텍 
         *      
         *      선형자료구조
         *      list, stack, queue, 배열     배열과 리스트는 상호보완적
         *      ArrayList
         *      
         *      비선형자료구조
         *      tree 
         *        -노드는 반드시 하나의부모를 가진다.
         *         노드는 0개 이상의 자식을 가진다.
         *         계층구조, 위, 아래가 있다.   부모, 자식관계
         *          root 
         *          leaf(터미널)
         *       
         *     
         *      
         * 6월 14일 ------------------------------------------------------------------------------------
         *           
         *   이진트리(Binary tree)
         *      노드가 최대 2개의 자식을 가지는 트리
         *      
         *    이진탐색트리(Binary Search tree)
         *      노드는 (최대 두 개) 까지만 자식을 가질 수 있다.
         *      노드는 키 값을 가진다.
         *      키값은 순서가 있는 데이터 이어야 한다.
         *      키값은 유니크한 것이 좋다
         *      모든 노드에 대해서 키값이 작은 것은 왼쪽에 있고 키값이 큰 것은 오른 쪽에 있다.(빨리 찾기 위함)
         *      
         *    균형트리 (Balanced tree) - 순서를 잘못배정하면 그냥 리스트와 탐색 속도가 별 차이가 없어지는 단점을 보완하기 위해 고안해낸 것 
         *    
         *    Heap - 
         *    -트리구조를 갖고있는 자료구조 
         *    - 완전 이진트리의 (Complete)구조여야한다
         *    - 우선순위를 판별하는데 유리하다
         *          749325618
         *    - 최대힙과Max   - 부모는 자식보다 커야한다.
         *    - 최소힙Min   - 부모는 자식보다 작아야한다
         *                              
         *                              MIN heap
         *                                  1
         *                        2                      5   
         *                 3           4            9       6
         *             7       8
         *
         *      그래프
         *           지하철 노선도 같은 느낌
         *             -계층구조없음
         *- n:n 구조
         * - 길찾기 알고리즘에 자주 사용된다
         * 비선형 자료구조 - 그래프, 트리
         * 선형자료구조 - 리스트, 스텍, 큐, 배열
         *
         *
         *
         *
         *  6월 15일 ---------------------------------------------------------------------------------------
         *      알고리즘 - 문제해결을 위한 절차를 순서대로 설명한것
         *      
         *          시간복잡도
         *              알고리즘을 처리하는데 걸리는 시간이 어느정도인지를 나타내는 것 
         *                  빅오표기법
         *                      O(n) 알고리즘 처리시간이 데이터 갯수에 비례한다.,
         *                      O(logN) 알고리즘 처리시간이 데이터 갯수가 늘어날수록 효율이 좋아진다.
         *                      O(n^2) : 알고리즘 처리 시간이 데이터갯수의 제곱으로 늘어난다. 기하급수적으로 늘어나기때문에 속도가 감당이 안된다.
         *                      
         *          
         *          공간복잡도
         *              알고리즘을 처리하는데 필요한 메모리 공간이 어느정도인지를 나타내는 것
         *              Ram 메모리 가격이 비쌌을 시절 중요했지만 현재는 중요도가 떨어졌다.
         *  ------------------------------------------------------------------------------------------------------
         *          정렬알고리즘 - 
         *          탐색알고리즘 - 
         *          
         *          해시알고리즘 - Hash 값(데이터의 요약본)을 구하는 알고리즘 
         *              1Tb  요약본 같이 패킷으로 보냄  원본과 비교 , 데이터 이동중 데이터손실, 손상이 없는지 확인
         *              -결과해시값은 서로다른 데이터 간에 중복이 없어야한다. 만약 다른데이터를 갖는 같은 해시값이 있다면 의미가 없다.
         *              서버의 비밀번호는 비밀번호를 직접 비교하는것이 아니라, 비밀번호의 해시값을 기준으로 검사를한다
         *          
         *          
         *          길찾기 알고리즘
         *          
         *              다익스트라 알고리즘
         *                  모든 경로를 다 계산하기 때문에 느리다. 효율적인 편은 아니다.
         *              
         *              A* 알고리즘 
         *                  
         *              
         *              암호화 알고리즘
         *                  시저 알고리즘
         *              
         *  6월 16일 ------------------------------------------------------------------------------------------------------------------------------------
         *      A*알고리즘
         *          출발지에서 목적지까지 최단경로를 계산하는 알고리즘
         *          그래프 기반
         *          휴리스틱(경험적) 함수 사용 => 각 개별 게임에 적합한 커스터마이징이 쉽다.
         *          (함수)F(x) = g(x) + 휴리스틱 h(x)
         *          A*알고리즘 =  출발점에서 중간지점까지 확정된 거리(g) + 중간지점에서 목적지까지 예상거리(h)
         *          옆으로 이동거리 1
         *          대각선 이동거리 루트2(1.4)
         *          
         *          OpenList - f값을 확인할(탐색할) 후보 노드 
         *          
         *          OpenList에 먼저 추가하고 탐색이 끝나면 CloseList 로 옮긴다
         *          f값이 가장작은 것을 다음 탐색 대상 
         *          
         *         
         *          
         *          
         *           f  
         *                  (x)
         *          g(확정)          h(목표지점까지)
         *          CloseList - 이미 탐색이 끝난 노드                        
         *         
         *  
         *  
         *          0      1      2      3      4      5      6   
         *                                                   
         *                                                   
         *          7      8      9      10     11     12     13
         *                                                   
         *                     9.4                              
         *          14     15     16     xx     18     19     20
         *                    1.4   8                            
         *                      10                             
         *          21     @@     23     xx     25     26     27
         *                      1    9                         
         *                                                   
         *          28     29     30     xx     32     33     @@
         *                                                   
         *                                                   
         *          35     36     xx     xx     39     40     41
         *                                                   
         *                                                   
         *          42     43     44     45     46     47     48
         *  
         *  
         *      암호화 알고리즘
         *          디지털 시대로 접어들면서 정보(데이터)의 복사가 너무 쉬워졌기 때문에 암호화알고리즘이 중요하게 되었다.
         *              평문(Plain Text) : 암호화되지 않은 데이터
         *              암호문(Cipher Text) : 암호화 된 데이터
         *              평문을 암호문으로 바꾸는 것 => 암호화 (Encription)
         *              암호문을 평문으로 바꾸는 것 => 복호화 (Decription)
         *              
         *              
         *              대칭 키 알고리즘  : 암호화와 복호화를 하는데 같은 키 값을 사용한다
         *              Des 
         *              Aes
         *              대칭키 알고리즘 의 문제  키를 탈취당할 위험이 항상 존재한다.
         *              
         *              공개 키 알고리즘 :  비밀키(공인 인증서 방식) 전자서명
         *                                 공개키 
         *  
         *  
         *  2D오브젝트 - 스프라이트 렌더러// 3D오브젝트 - Mesh Renderer,
         *  디퓨즈 - 디폴트값, 스펙큘러 - 난반사 어느각도에서 봐도 같은 색
         *  
         *  메시랜더러는 반드시 하나이상의 material 을 갖고있다.
         *  albedo = 빛 반사도
         *  Opaque = 불투명한 물체
         *  transperant = 반투명
         *  cutout
         *  Fade = 어느부분은 투명하고 어느부분은 불투명할때
         *  Material은 많으면 많을수록 연산량이 무겁고 많아진다 Material 하나당 drawCall 하나 
         *  Normal map - 하이폴리곤의 노멀백터를 기준으로 그림자를계산
         *  highPolygon은 연산량이 부담이 많이된다
         *  
         *  Directional Light 태양 역할
         *  pointLight 지정 영역까지만 빛을 뿜음 횃불같은 느낌
         *  
         *  조명이 늘어날수록 연산량이 많아지고 성능에 부하가 많이 걸린다.
         *  
         *  ------------------------------------------------------------------------------------------------------------
         *  6월 28일
         *  ------------------------------------------------------------------------------------------------------------
         *  벡터의 구성요소 
         *  방향과 스칼라(크기)
         *  
         *  방향벡터 구하기
         *  A 에서 B위치로 향하는 방향벡터 코드 완성해라
         *  
         *  4-1 숫자나 기호를 사용하여 위치정보를 표시하는것
         *  - 좌표계
         *  
         *  z축방향에 따라 구분하는 좌표계
         *  왼손, 오른손 좌표계
         *  
         *  
         *  리스트의 장점 - 데이터이 삽입삭제가 빠르다.
         *  
         *  리스트의 단점 - 탐색시간이 데이터 갯수에 비례한다.
         *   Head부터 순차적으로 탐색해야하기 때문에 
         *   
         *   6.알고리즘이 문제를 해결하는데 걸리는 정도를 표현하는것 
         *      시간복잡도
         *      
         *  시간복잡도를 나타낼때 사용하는 표기법
         *      빅오 표기법
         *      
         *  ------------------------------------------------------------------------------------------------------------------------------
         *  필기문제
         *  
         *  깊은복사 데이터 타입
         *  값타입
         *  
         *  외적의 결과를 어떻게 활용할 수 있는가 
         *  결과는 노멀벡터, 반사 계산,사이각에 따라 앞 뒷면 판단, 왼쪽 오른쪽 판단
         *  
         *  
         *  싱글 링크드 리스트의 노드구성
         *      데이터 + 다음노드의 참조
         *  
         *  5. 해시 알고리즘 에서 가장중요한것
         *      해시충돌이 있으면 안된다. 같은해시에서 다른 원본이 나오면 안된다.
         *  
         *  6. 구, 캡슐, 박스 연산량이 적은 순
         *      구 - 캡슐 - 박스(일반적인 상황)
         *  
         *  7. 긴급처리 시스템에 적합한 자료구조
         *      Stack - 후입선출 LIFO 
         *      
         *  8. 키프레임 에니메이션의 원리
         *      키프레임만 저장하고 중간부분을 보간을 통해 계산하여 보여준다.
         *      
         *  9. 두 벡터의 사이각은 어떻게 계산할 수 있는가
         *      내적과 삼각함수를 이용한다.
         *      내적 구하는방식 각 xyz를 곱한 후 더한다.
         *      
         *  10. A* 알고리즘의 가장 쉬운 성능개선법
         *      H값 휴리스틱 함수를 조절 테스트 개선해야한다. 

         *  11 1byte 데이터에 세번째자리의 플래그를 확인하는 방법은 어떻게 되는가
         *      이진수 100 과 데이터를 & 를 해서 0이 아니면 플래그가 세팅된 것이다
         *      
         *  12. 구와 구의 충돌 
         *      두 물체의 중심점간 거리와 두 물체의 반지름의 합을 비교한다
         *  
         *  ------------------------------------------------------------------------------------------------------------
         *  6월 30일
         *  ------------------------------------------------------------------------------------------------------------
         *  API(인터페이스) - application programing interface   - 특정기능을 모듈화해서 제공하는 인터페이스
         *  
         *  Library : 함수나 클래스의 모음집
         *  
         *  DLL - Dinamic Link Library
         *  
         *  SDK - Software Development Kit -어떤 소프트웨어를 만들기 위한 라이브러리, 툴들을 모아놓은것
         *  
         *  Game Engine : 개임개발에 필수적으로 필요한것들 입력, 출력, 렌더링, SDK
         *  
         *  유니티의 장점 멀티플랫폼 지원
         *  게임내 자체 콘솔창은 테스트의 편의를 위해 만들어졌다.
         *  
         *  파일로드 Resources.Load //항상 메모리에 존재하기 때문에 메모리 낭비가 심하다
         *  
         *  유니티 생명주기 이벤트함수 실행순서
         *  
         *  카메라 투영방법 퍼스펙티브(원근투영)  : 멀리있는 것을 작게 그린다 
         *         오소그래픽(원근감이 없음)
         *  
         *  -------------------------------------------------------------
         *  Line : 특정 위치 두 개 를 이은 선, 최단거리(위치 2개) 
         *  
         *  Ray : 특정위치에서 특정 방향으로 나가는 선(위치1개, 방향 1개)
         *  
         *  -------------------------------------------------------------
         *  VR : Virtual Reality - 고개를 돌리면 카메라가 돌아간다. - 디스플레이가 두객 붙어있고 카메라도 2개이다. 왼쪽 오른쪽 눈에 다른 정보를 주어서 입체감을 준다
         *  
         *  HMD : Head Mounted Display - 고개를 돌리면 화면이 따라움직인다.
         *  
         *  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
         *   7월 4일
         *   ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
         *  SDK (Software Development Kit): SDK는 특정 소프트웨어 패키지, 소프트웨어 프레임워크, 하드웨어 플랫폼, 컴퓨터 시스템, 운영 체제, 게임 콘솔 등을 위한 개발 도구 모음.
         *  SDK는 일반적으로 API, 프로그래밍 언어에서 사용할 수 있는 라이브러리, 개발 환경 설정 방법, 코드 예제, 기술적인 설명서 및 가이드 등을 포함합니다.
         *  이를 통해 개발자는 해당 플랫폼이나 언어를 활용해 효율적으로 코드를 작성할 수 있습니다.

            DLL (Dynamic-Link Library): DLL은 Microsoft Windows에서 사용하는 실행 파일 형식 중 하나로, 프로그램이 필요로 하는 코드와 리소스를 제공합니다.
        DLL 파일은 여러 프로그램에서 공유하여 메모리와 디스크 공간을 절약하는 데 도움이 됩니다. 또한, 프로그램의 기능을 확장하거나 업데이트하는데 유용하게 사용될 수 있습니다. 
        DLL은 프로그램 실행 중에 동적으로 로드되고 연결되므로 "동적 링크"라는 이름이 붙었습니다.

            Library (라이브러리): 라이브러리는 프로그래밍에서 재사용 가능한 코드 조각이나 데이터의 모음을 가리킵니다. 
        라이브러리는 특정 기능을 구현하는데 필요한 코드를 캡슐화하여 재사용성을 높이고, 개발자가 모든 것을 처음부터 코딩하지 않아도 되게 해줍니다.
        예를 들어, 수학적 계산이나 파일 조작과 같은 공통적인 작업을 처리하는 함수들을 라이브러리로 묶어 다른 프로그램에서 호출해서 사용할 수 있습니다. 
        라이브러리는 정적 라이브러리와 동적 라이브러리(DLL이 하나의 예)로 나뉘며, 이들은 빌드 시점에 바인딩 되는지 실행 시점에 바인딩 되는지에 따라 구분됩니다.

            이 세 가지 모두 개발 과정을 단순화하고 효율화하는데 도움이 되는 도구입니다.
         *  
         *  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
         *  7월 20일
         *  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
         *  1. 상용게임 엔진 - 유니티, 언리얼
         *  2. 상대적 가벼운 멀티플랫폼게임을 만들기 적합한 엔진  - 유니티, etc
         *  2-1 Unity 버전관리, 프로젝트관리 툴 - unity hub
         *  
         *  2-2 스크립트 에디터는 어떤 것들이 있는가 - VisualStudio, IDE 와 스크립트 에디터는 구분되어야한다
         *  3-1 게임오브젝트를 구성하는 최소단위 - 컴포넌트
         *  3-2 스크립트로 게임오브젝트에 RigidBody 추가하기
         *  
         *  4-1 씬에 배치되는 최소단위 - GameObject
         *  4-2 게임오브젝트를 만들기 위해 상속받아야하는 클래스
         *  
         *  5-1 일반HMD ,VR   HMD가 더 포괄적인 개념이다. HMD 안에 VR이라는것이 존재한다.
         *      차이점 헤드트레킹
         *  
         *  5-2 VR기기는 어떤 것들이 있는가
         *      오큘러스, 메타퀘스트, 벨브인덱스, HTC Vive, PS VR
         *  
         *  6-1 입체감을 주는 원리 - 양안시차를 이용해서 두개의 카메라에서 각각 랜더링해서 두개의 스크린에 각각 조금씩 다르게 보여줌
         *  
         *  VR기기의 회전을 측정하는 센서 gyroscope Sensor
         *  
         *  
         *  
        */
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7월 21일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
게임 클라이언트 프로그래밍

 Data Type 데이터 타입 
- 정수, 실수 (소수점이 있는가 없는가 )
정수 - int, bit, byte, short, ushort, long, ulong
실수 - float, double, decimal
bool
string
char
구조체, 클래스  

Garbage Collection - 
	더이상 사용되지 않는, 참조가 없는 메모리를 자동으로 수집하여 해제하는 C#의 기능 (처음엔 Java 에서 시작되었다.)
	메모리 해제를 만약 수동으로 해줘야 하는 상황에서 헤제를 하지 않으면 조금씩 메모리 누수가 일어나게된다. 
	reference Count가 0이 되면 콜렉터가 수거해간다


메모리 풀 
	메모리를 한번에 크게 할당해 놓은 후 필요한 만큼 풀에서 넘겨받아 사용하는 기법	
	장점 : 메모리 동적할당을 미리 처리하여 실시간 성능을 높일 수 있다.
	메모리 단편화 현상 - 요청한 메모리의 크기가 여러군데 나눠져 있어 잉여공간이 있음에도 할당하지 못하고 새 공간을 할당해야하지만 메모리풀을 사용하면 초기 할당되는 크기가 일정하기 때문에 
	단편화현상을 막을 수 있다.
	
오브젝트 풀
	생성, 파괴의 빈도가 잦은 오브젝트를 미리 필요한 만큼 만들어놓고 필요할때 활성화, 사용후 비활성화 하는 기법
	장점 : 메모리 동적할당을 미리 처리하여 실시간 성능을 높일 수 있다.(파괴될때 생기는 가비지도 줄일 수 있다.)



자료구조
	배열
	Generic Collection : List, Queue, Stack, Dictionary(해시를 이용한 2진트리와 유사한 구조) Generic Collection 은 Boxing이 일어나서 참조타입으로 바꿔준다
	Boxing, UnBoxing - 값타입과 참조타입의 변환 
	

접근제한자Access Modifier, - 클래스나 구조체의 멤버에 대한 접근을 제한한다. 
	public - private, protected, internal

일반적으로 프로젝트 하나당 실행파일 1개 


프로그래밍 패러다임
	프로그램을 어떻게 동작시킬 것인가?
	절차지향 프로그래밍 - 직관적으로 순서를 한눈에 파악하기 쉽지만 (선행되는작업의 결과를 기반으로 후행되는 작업을 실행하기 때문에 ) 반드시 순차적으로 작업해야하기 때문에 여러명이 작업을 하기 힘들다.
	객체지향 프로그래밍 - 각 객체의 역할을 나누고 프로그램이 실행되면 각자 역할을 수행한다.
	Event Driven 프로그래밍 - 어떤 이벤트가 발생하면 그 이벤트에 반응해서 동작을 하게 만들면 된다.
				이벤트 : 프로그램에 의해 감지되고 처리될 수 있는 동작이나 사건 ex> inputSystem
				CPU 가 쓸데없는 상태체크를 자주 반복하는것을 방지하기 위함(busy Wait) Update에서 if 를 체크해야할 경우 
				전원이 안정적으로 들어와서 배터리 걱정이 없는경우보다 노트북, 모바일 등 의 사용량이 늘어나면서 전력사용량을 줄이는 방법을 강구하게 되었다.
				평소 최소 전력만 유지하도록 하는 추세 이다. Ram 유지전력(전원이 나가면 Ram에 남아있던 메모리는 모두 해제 된다.)
			OnMove에서 직접 움직이지 않고 Update에서 움직이는 이유는 뭘까?

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7월 24일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
예외처리(Exception)
 	컴퓨터가 어떻게 동작할지 프로그래머가 설정하지 않은 모든 것
		뻗기 전 어떤 이유로 뻗었는지 알려주는 것
	예외처리용 코드
		try{

		    } 
		catch(Exception e) // 느려서 게임쪽에선 잘 안씀 

	C#의 견고함 => C++ => 종료 

Raycast, Hit Scan, Picking
	Picking
	마우스포인터의 스크린좌표를 카메라로 투영해서  카메라위치에서 nearPlane(프러스텀뷰의 앞쪽)의 마우스 위치로 나가는 레이를 만든 후 
	그 레이에 충동하는 오브젝트가 있는지 검사하는 것

	Raycast
	특정 레이가 다른 오브젝트와 충돌하는지 안하는지 검사하는 기법

	HitScan
	레이캐스트를 사용하여 충돌하는 오브젝트가 있는지 검사하는 기법(FPS) 총구(origin)
	Ray- 원점으로부터 계속해서 뻗어나가는 선 


유니티
	Scene : 맵 하나
	GameObject : 씬을 구성하는 기본 요소 
	Component : 게임오브젝트를 구성하는 기본요소 
	
	게임오브젝트를 찾는법
	
	성능 테그 -> 타입 -> 이름
	GameObject.FindWithTag, FindObjectOfType, Find => 씬 전체에서 찾음
	transform.Find => 자식오브젝트중에서만 찾음

	컴포넌트 찾는법
	GetComponent : 이 스크립트를 갖고있는 게임오브젝트에서만 찾는다.
	GetComponentInChildren : 이 스크립트를 갖고있는 게임오브젝트와 자식까지 포함해서 찾는다.

	컴포넌트와 게임오브젝트 또는 무언가를 찾는다는것은 성능의 부하가 많다. 따라서 자주 찾아야하는 것이라면 미리 캐싱을 해 두는 것이 좋다

	Terrain 기본 단위 width, height 1000, 1000 넓은 맵을 작은 성능부하로 만들 수 있다.
	일반적으로 오픈월드 규모의 대형게임에서 사용된다.
	
	높이 맵() 적은 양의 메모리로 넓은 지형을 표현 가능하다 1바이트만 사용
	등고선처럼 높이가 높을 수록 1픽셀 단위로 색깔을 더 진하게 저장한다. 색깔로 높낮이를 저장
	단점 : 높이가 겹칠 수 없다 (동굴 불가능), 지형이 단조롭다, 급경사가(절벽) 불가능하다		





ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7월 25일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
유니티 특수폴더

Assets 
	프로젝트에서 모든 에셋의 Root
	프로젝트창에서 확인가능

Editor
	이 폴더 안에 있는 스크립트는 유니티 에디터용으로 간주 - 에셋포더 밑에 있으면 위치와 개수는 몇개든, 어디있든 상관없다.	

Resources
	이 폴더 안에 있는 에셋은 런타임에 동적 로딩이 가능하다 어디에 있어도 상관없다. 편리하나. Resouces 폴더에 있는것은 무조건적으로 메모리에 미리 로드해줘야해서 
	메모리관리가 어렵다는 단점이 있다. 빌드, 및 게임실행시간이 길어진다.

프로젝트 - 프로젝트에서 사용될 모든에셋을 볼 수 있는 창

인스펙터 - 에셋, 컴포넌트의 상세정보를 보고 수정할 수 있는 창


TMP - 폰트에셋을 기준으로 글자 이미지를 생성

입력방식
	인풋메니저 - 전통적인 Polling방식(계속 인풋이 있는지 실시간으로 확인함) 인풋 렉이 있을 수 밖에 없다 - 전원Power 가 항상 켜져있어야해서 전력, 배터리사용량이 커진다busy Wait

	인풋시스템 - 비교적 새로나온 - Event Driven방식  특정 이벤트가 발생 했을 때


이벤트함수 실행순서 


충돌처리 - Collision 두 오브젝트 중 최소 하나는 RigidBody를 갖고 있어야한다.

겹침 - trigger 두 오브젝트 중 최소 하나는 RigidBody를 갖고 있어야한다.


애니메이션
	Animator 컴포넌트로 애니메이션 실행
	Clip : 애니메이션 하나를 표현하는 에셋 
	Controller (상태)클립 간 트렌지션을 정의하는 에셋  언제 실행할 것인지

애니메이션 리타게팅
	같은 본 구조를 갖고있는 오브젝트의 애니메이션을 재활용하는 기법
Avatar : 인간형 애니메이션 재사용을 위한 본의 매핑정보를 저장하는 에셋
	
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7월 31일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
심리스 맵 로딩
현재 위치한 맵과 그 맵에 인접한 맵을 백그라운드에서 로딩 한 후  플레이어가 이동할 확률이 높은 맵을 우선적으로 로딩하고  이동할 확률이 적은 맵은 로딩을 해제하는 방식

객체의 성성, 파괴 빈도가 높을경우 메모리풀을 사용하애하는 이유
메모리의 할당과 해제는 시간이 많이 필요하기 때문에 내부적으로 큰 버퍼를 만든다. 따라서 따로 관리하는 거이 성능에 도움이 된다.


정수비교와 문자열 비교
문자열도 결국 내부적으로 숫자의 집합이다.  문자열의 길이만큼 비교가 발생된다.


마우스피킹 - 마우스포인터의 스크린좌표를 카메라클래스를 이용해서 역으로 투영하여  카메라위치에서 near Plane 의 마우스 위치로 나가는 레이를 구성한 후 레이와 충돌하는 오브젝트가 있는지 검사하는 기법

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
20230801
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
게임 인공지능 프로그래밍

DLSS : Deep Learning Super Sampling

	인공지능 artificial Intelligence - 인간의 지능을 인공적으로 구현하려는 컴퓨터 과학의 한 분야
	발전 속도가 상대적으로 매우 빠르다.

	인공지능의 분류 
	- 약 인공지능 Weak - 미리 정의된 규칙에 따라 특정한 문제만 해결 가능한 인공지능.(Bot) - 사람처럼 보이게 하는것이 최선 - 현재 존재하는 대부분의 AI
	- 강 인공지능 Strong - 범용 인공지능 - 진짜 사람처럼 생각하는 인공지능 , 인간과 비슷하거나 더 나은지능을 가진AI, 정해진 규칙이 없더라도 스스로 룰을 파악가능
	- 초 인공지능 Super - 인간의 사고를 아득히 뒤어넘은 수준의 인공지능

	인공지능시스템의 종류
	- 자연어(일상적 언어) 처리 , 일상적 언어를 컴퓨터가 이해하게 하는것, AI비서, 번역
	
	- 전문가 시스템(고전적)
	  특정 분야에 대한 전문적인 지식을 컴퓨터에 기억시킨 후 상황을 입력하면 기억된 지식에 따라 결론을 출력하는 시스템

	- 머신러닝(기계학습)
	  컴퓨터가 데이터를 평가하고 일반화하는 방법을 학습하여 원하는 기능을 자동으로 개선하는 알고리즘 시스템()
	 
	 딥러닝(기보학습)
	 머신러닝의 방법중 하나로 다량의 인공신경망을 통해 예시 데이터에서 일반적인 규칙을 학습하는 방법
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
8월 2일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	게임 - 정해진 룰에 따라 승패를 정하는 것들

	게임 내 인공지능 시스템
	과거 사람대 사람간의 게임만 존재하던 예전에는 필요가 없었지만 비디오게임이 나오면서부터 상대방이 없어도 게임을 플레이하고자하는 욕구가 생겼다. 따라서 게임 인공지능이 생겨났다.
	플레이어를 상대할 적 또는 NPC의 동작을 사람처럼 보이게 만드는 AI, 너무 수준이 낮으면 몰입이 깨지게 된다(최대한 자연스럽게 사람처럼 움직일수록 좋다)

	길찾기 - 사람처럼
	마인크래프트 Java, C++ 마소 인수 후 c++ 전환


	DLSS : Deep Learning Super Sampling 엔비디아의 인공지능을 이용한 업스케일링 기술 // 그래픽카드의 성능이 4K 해상도에 맞게 갑자기 상향될 수 없기 때문에 DLSS를 이용한다.
	
	퀘스트 자동생성
	GPT를 이용한 TRPG 
	
	인공지능으로 행동을 표현하는 방법 
	유한 상태 기계 (Finite State Machine) if, else 분기를 이용해 특정 조건을 만족하면 특정 행동을 하게 한다. @@@@상태와 조건
	프로그램을 설계하는데 사용되는 수학적 모델 중 하나 
	유한한 개수의 상태를 가지는 기계가 있고, 기계는 한번에 하나의 상태를 가진다.
	이벤트에 의해 상태가 다른상태로 변화할 수 있다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
230803
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	Behaviour Tree
	- 특정 계획에 따라 작업을 수행하기 위해 트리구조의 수학적 AI 모델
	
 	- NPC의 행동을 모델링 하기 위한 강력한 도구로 시작된 모델 
	
	- 우선순위 별로 Leaf 시퀀스, Selector가 배치된다.

	- 구성노드 : 시작노드 Root, 제어흐름 노드(Control Flow), 작업노드(Task)
	
	- 제어흐름노드  
	   컴포짓 : 시퀀스Sequence(조건문이 실행되기 전까지 계속 실행됨), 셀렉터
	   데코레이터 (Decorator) : 조건문, 컴포짓과 연결됨, Task를 실행할 떄도 사용됨


길찾기 알고리즘
	맵의 구조를 저장하기 좋은 자료구조  - 일반적으로 그래프를 사용한다.
	
	삼각형의 중심점 위치를 저장, 노드(위치), 엣지(노드를 잇는 거리)
	
	
	다익스트라 알고리즘 
	    미국 우편
	    시작노드에서 다른 모든 노드로의 최단경로를 구할 수 있다. 

	A* 알고리즘
	    시작 노드에서 목적지노드 사이의 최단경로만 계산
	    모든경로에대한 정보가 필요없다
	    휴리스틱 값을 사용하여 알고리즘을 개선할 수 있다.
	    네비게이션 매시와 조합하여 사용할 수 있다.
	    F(x) = g(x)확정거리 + h(x)목적지까지 예상거리

	네비게이션 메시
	    지형을 그래프로 변경하기 위해 폴리곤의 집합으로 변경한 매시. 적절히 삼각형으로 잘 쪼개야 자연스럽다.
	    삼각형의 중심점 위치를 저장, 노드(위치), 엣지(노드를 잇는 거리)
	    장점 : 이동중 지형과 충돌검사를 할 필요가 없다, 충돌지점까지 갈 일 이 없기때문에
		그래프검색 알고리즘을 쉽게 적용할 수 있다.
		그리드방식에 비해 거리, 면적을 상세하고 유연하게 지형을 표현가능 하다.

	    단점 : 미리 네비게이션매시를 만들어야한다. 그렇기 때문에 런타임에 지형이 변경되는 경우는 네비게이션매시 외의 다른방법을 사용해야 한다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
8월 9일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
1-1 인공지능

1-2 전문가시스템
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
2-1
범용인공지능(강 인공지능) - 상황에 따라 판단, 추론, 문제해결이 가능해야 한다

2-2 
특정 문제,목표를 해결하기 위한 도구로 활용되는 인공지능 - 약 인공지능
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
3-1
유한한 상태를 가지고 특정 이벤트에 의해 상태가 변경되는 수학적 모델 - 유한상태기계
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
3-2
상태변경을 일반적으로 "전이, 트렌지션" 이라 부른다
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
4-1 
특정작업을 수행하기 위한 트리구조의 수학적 AI모델 NPC 의행동을 모델링하는데 많이 쓰이는 모델 - behaviour Tree

4-2
모델을 구성하는 노드들에는 어떤 것들이 있는가
- 시작노드Root, 제어흐름Control Flow, 작업노드Task
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
5-1 NavMeshAgent 목적지까지 남은 거리 구하기
     float distance = agent.remainingDistance;

5-2
에이전트가 목적지에서 1UnityUnit 안으로 들어가면 도착한 것으로 간주하는 코드
- agent.stoppingDistance = 1.0f;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
6-1
ㅡㅡ
6-2
순간이동 코드
agent.Warp(vector3)


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
8월 10일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
게임그래픽 프로그래밍

	Mesh - 외형, 
	색깔에 영향을 미치는 것 
		Texture - UV좌표
		조명 - 
			동적 조명은 성능에 매우 심하게 영향을 미친다. 
			

			directional  - 위치와 관계 없이 방향만 가지는 조명(평행광선) 해가 떠있는 것 처럼 씬 전체에 균일하게 영향을 주는 조명, Transform 컴포넌트의 회전에 영향을 받는다.

			Point - 원점(Point) 으로 부터 설정한 반지름 만큼 빛이 퍼져나간다. 원점으로부터 멀어질 수록 빛의 강도가 약해진다. 
				주의할 점은 Light만 있고 주면에 아무런 오브젝트(빛을 반사할 대상) 가 없으면 빛이 보이지 않는다.

			Spot - 무대조명, 휴대폰의 플래시 느낌, 어떤 것을 강조하고싶을 때 
				특정 위치에서 특정 방향으로 바라보는 원뿔모양으로 빛을 내보내는 광원

			(Additional)
			Area(Baked only 미리 구워놓는 것) - 형광등같은 사각형 조명 		
			Light Prove - 각 점 마다 받을 빛을 미리 계산해놓음
			Reflection Prove - 반사광 미리 구워놓기
				
			공통 파라미터 
				Color, Intencity
	
		
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
8월 11일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	그림자
		Shader -> Shadow += er
		원래는 그림자를 입히는 작업
		컴퓨터그래픽스에서 3D장면의 음영계산, 특수효과, 화면 후처리 등의 작업을 수행하기 위해 사용하는 소프트웨어
		GPU의 프로그래밍 가능한 랜더링파이프라인을 사용하는 소프트웨어 명령의 집합
		
		CPU, GPU 
	               control Unit(코드 순서 제어), ALU(단순 계산), Cache(자주 사용될 것이라고 예상되는 데이터) DRAM

		GPU - 컨트롤유닛, Cache 가 작다 단순계산
			 
	셰이더 구현방법의 종류
	- 셰이더용 언어(Unity 지원)
	   - HLSL(High Level Shader Language)
	   - GLSL(OpenGL Shading Language)
	   - CG(C for Graphics) 엔비디아

	- Unity의 셰이더 지원
	   - Surface Shader : 머티리얼의 물리적특성을 정의해주는 유니티의 셰이더 언어(표면용 셰이더)
        	   - Shader Graph : 노드기반으로 셰이더 코드를 작성할 수 있게 해주는 툴, 중간과정을 보여줌으로써 디버깅이 편리함, 그러나 직접 코드로 작성하는 것 보다 속도, 성능 측면에서 안좋다.
	

	   - DirectX 마이크로소프트
	   - OpenGL - 마소의 횡포에 못이겨 생겨난 오픈소스

          	   언어 - 기계어 -> 어셈블리어
		highLevel Language - > 사람이 알아보기 쉽다. -> 컴퓨터가 알아볼 수 있게 컴파일 과정이 필요하다
		LowLevel Language -> 컴퓨터가 알아보기 쉽다. -> 속도가 빠름		
		
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
8월 14일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	셰이더의 종류
	  - @@Pixel 셰이더 pixel(가장 작은 단위)
		스크린에 최종 출력되는 픽셀들의 색상이나 다른 특성들을 계산하여 변경하는데 사용되는 셰이더
		픽셀 하나하나를 입력받아서 필요한 효과에 따라 여러 계산을 진행한 후 결과값으로 픽셀의 정보를 변경한다.
		픽셀하나를 파라미터로받아서 함수를 처리한후 리턴.

`		unlit - 그림자 없는


		프레그먼트 셰이더 - 픽셀 셰이더를 조금 더 일반화한 셰이더 
		  - 픽셀셰이더와 비슷하지만 색깔을 표현하는 단위가 조금 다르다.

		
	  - @@Vertex 셰이더 (정점 셰이더)
		3D모델의 각 정점이 가지는 데이터를 계산하고 변경할 수 있는 셰이더 
		대상 정점들을 입력으로 받은 후 필요한 효과에 따라 여러 계산을 진행한 후 결과값으로 각 정점의 정보를 변경 

		geometry(없는걸 더 만듦), tesselator(있는걸 쪼갬),셰이더 삼각형을 더 잘게 쪼개 세분화한다.

	PipeLine - 과정

	랜더링
	  - 랜더링 파이프라인
		3D오브젝트들로 구성된 월드를 디스플레이에서 출력하기 위해 2차원 래스터이미지로 변경하는 단계적인 방법을 설정해 놓은 것 

	  -  Unity SRP (Scriptable Rendering PipeLine) 
		과거에 비해 발전 속도가 워낙 빨라서 엔진을 다룰 줄 아는 프로그래머의 수가 희소해졌다.
		
		LWRP(Light weight) 경량, 가볍고 빠르게 돌리는 대신 퀄리티는 soso -> 현재 URP로 바뀜 (Universal) 
		HDRP(High Definition), 고퀄리티 전용

	  - 랜더링 방식
		Foward Rendering
		  - 고전적인 랜더링 방식 
		  - 각 3D오브젝트를 랜더링 파이프라인에 따라 하나씩 그리는 랜더링 방식
		  - 조명과 오브젝트가 늘어날수록 부하가 기하급수적으로 늘어남 n제곱 으로 연산량이 늘어남
		  - 매개변수  : Diffuse(난반사)(색깔), specular(정반사), Ambient(환경색)

		Physically Based Rendering(물리기반 랜더링)
		  - 실제 빛이 어딘가에 충돌했을때 어떻게 결과가 나올지를 시뮬레이션해서 랜더링하는 방법
		  - 좀 더 사실적인 랜더링이 가능해 진다., 매개변수의 의미를 더 직관적으로 받아들일 수 있어 결과값을 예상하기 더 쉬워진다.
		  - 매개변수의 종류 : albedo(반사도)어떤 색을 반사하는가(색깔), Metalic, SmoothNess(정반사 될 것인지 난반사가 될 것인지 결정)



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
8월 16일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	유니티 특수효과
		Trail Renderer - 수명을 가진 꼬리 (자동차 배기가스 표현 등에 사용), 움직이는 오브젝트 뒤에 폴리곤 이팩트가 흔적으로 남은 효과를 주고 싶을 때 사용하는 컴포넌트
		파라미터
			Time(수명)
			vertex distance 내부 삼각형 메시간의 거리 촘촘하게 할수록 퀄리티와 연산량이 올라감
			width - 
			color			

		Line Renderer -
		파라미터
			Loop
			color
			

		파티클
		  - 지원하는 시스템
			파티클
			3D 그래픽스에서 매우 작은 이미지나 메시를 대량으로 생산해 시뮬레이션 하고 랜더링해 시각효과를 생성하는 것
			대량생산을 전재로 하기 때문에 복잡한 메시는 성능에 곧바로 큰 영향을 미친다
			  - 주요요소
				머티리얼, 수명, 색상, velocity, 위치, 크기, 개수		

			유니티가 제공하는 시스템 : Particle System(컴포넌트), Visual Effect Graph(VFX)(URP 도는 HDRP 둘중 하나를 사용하고 있어야 한다.)
						씬당 천개단위 			씬당 10만단위 이상

										VFX 단순계산은 잘 하지만 충돌처리등을 할 수 없다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
8월 17일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	포스트 프로세싱 - 후처리
	  - 랜더링한 이미지가 화면에 나타나기 전에 일종의 필터처리를 하는 것 
	  - 종류
		Bloom : 밝은 부위에서 빛이 번지는 효과를 추가해 준다.
		Vignette : 카메라 가장자리(외곽부분) 을 어둡게 만드는 효과를 추가해준다
		안티엘리어싱(Anti - Aliasing) : 픽셀단위로 그리기 때문에 계단현상이 생기는 것을 Blur 효과를 줘서 방지하는 방법

		피사계심도(Field of Depth) : 초점을 맞추고싶은 대상을 제외한 나머지부분의 이미지를 흐릿하게 보여주는 효과 , 무언가에 포커싱하고싶을 때 사용한다.

		모션블러(Motion Blur) 카메라 이동방향에 맞춰 이미지를 흐리게 만드는 효과. 속도감을 높일 수 있다.

		노멀맵(범프맵)(Normal Map) : 노멀벡터 어떤 물체의 평면에 수직하는 벡터 ,조명, 그림자를 표현하는데 노멀벡터가 필요하다, 하이폴리곤 모델의 노멀맵(노멀벡터)을 텍스쳐 형태로 저장해놓은것(노멀맵)을
					 	로우폴리 오브젝트를 랜더링 할 때 그림자계산은 노멀맵을 이용해 처리하여 적은 양의 폴리곤으로도 뒤어난 품질의 그림자 결과를 만들어내는 기법
						단점이 거의 없고 장점이 커서 거의 필수적으로 사용한다.

		Level Of Detail (LOD) : 창문틈의 러버덕,  레벨이 높아질수록 폴리곤 수가 점점 줄어든다.
					폴리곤수에 상관 없이 크기가 아주 작더라도 성능에 영향을 주기 때문에 거리가 멀어서 잘 안보이는 오브젝트의 폴리곤 수를 거리에 따라 조절하여 보여주는 효과
					거리가 멀어질 수록 로우폴리모델을 사용하는 기법


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
8월 31일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

평가 풀이 

1-1 컴퓨터 그래픽스에서 3D장면의 음영계산 특수효과, 화면 후처리 등의 작업을 수행하기 위해 사용하느 소프트웨어 명령의 집합
1-2 

 	- 셰이더


2-1 스크린에 최종 출력되는 픽셀들의 색상이나 다른 특성들을 계산하여 변경하는데 사용되는 셰이더 
	- 픽셀셰이더		

2-2 3D 모델의 각 정점이 가지는 데이터를 계산하고 변경할 수 있는 셰이더
	- 정점 셰이더 Vertex 셰이더

3-1 Unity에서 셰이더를 작성하기 위해 사용하는 언어 종류
	- HLSL, GLSL, CG

3-2 Unity에서 물체의 물리적 특성을 간편하게 정의할 수 있도록 제공하는 셰이더
	- Surface Shader

4-1 3D 그래픽스에서 매우 작은 이미지나 메시를 대량으로 시뮬레이션하고 랜더링해 시각효과를 생성하는 것을 무엇이라고 하는가
	- 파티클

4-2 Unity 에서 파티클을 사용하기 위해 제공하는 컴포넌트의 이름
	- Particle System

5-1 파티클을 작성하기 위해 Unity가 제공하는 솔루션을 하나이상 답하시오
	- Particle System, Visual Effect Graph(VFX)

5-2 인스펙터창에서 Particle System 컴포넌트를 사용하는 간단한 파티클 작성 솔루션은 무엇인가?
	-Particle System	- 

6-1. 파티클 재생 함수이름
	Play();

6-2. 정지 함수 이름 
	Stop();


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 1일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
게임 UI, UX 기획

	인터페이스 - 서로다른 두개의 시스템이나 장치 사이에서 정보, 신호를 주고받는 접점, 경계면

	UI - 화면에 표시되는 그래픽 등을 통해 게임시스템과 사람간의 상호작용을 가능하게 해 주는 것
	     게임 내 UI는 GUI라고도 한다.

	종류 - 
	 이미지, 패널 : 스프라이트나 텍스쳐를 표시하는 UI패널 / 라인그리드 방식
	 텍스트 : 글자를 표시하는 UI
	 버튼 : 기본적으로 이미지이다. 상태에 따라 표시되는 이미지가 변경된다. 
		버튼의 상태 : normal, Press, Over, + Pressed?
	 	버튼의 파생 토글 : 둘 중 하나가 꼭 선택 될 때
			   radio버튼 : 여러 선택지 중 하나를 선택할 때 사용하는 UI
			   check 버튼 : 여러 선택지 중 0개 이상 선택 할 때
	슬라이더 
	 - 주로 마우스로 드래그 해서 미리 정해진 범위의 숫자를 선택할 수 있는 UI
	 
	 스크롤바 
	 - 한번에 볼 수 없는 큰 이미지나 많은 컨텐츠를 볼 수 있게 스크롤 기능

	 - UX
	  - 사용자가 어떤 시스템, 제품, 서비스를 직, 간접적으로 이용하면서 느끼는 감정, 생각 등을 포괄한 총체적 경험 UI

	 - 즐길 수 있는 컨텐츠가 제한이 없는 지금같은 시대에는 UI가 불편하면 금방 다른 컨텐츠를 찾아 떠나게 된다.
		최근의 나쁜UX의 예 디아블로4
	
		

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 4일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	컴퓨터란 전문가의 전유물 이었지만 컴퓨터의 대중화로 인해 UI, UX의 중요성이 부각되기 시작했다.
	무엇이든 익숙치 않은 것에대한 반발심이 있다. 
	UI, UX 는 새로운 것을 쉽게 받아들일 수 있게 도와준다. 따라서 아주 획기적으로 뛰어난 UX를 주기 힘들다면 유저들에게 익숙한 구조가 무난하다.

	좋은 UX의 장점 : 사용자의 학습시간을 줄일 수 있다.

	UX, UI 를 파악하기 위해서라도 개발자는 게임을 많이 즐길 필요가 있다.
	유저입장에서 개발자가 게임에 대해 잘 모른다는 생가이 들면 게임에 대한 신뢰도가 급락하게 된다.

	게임용 입력인터페이스, 하드웨어
	  PC : 키보드 - 다양한 입력이 가능하다, 높은 보급률  // 단점 : 온, 오프 둘 중하나만 선택가능 아날로그적 입력 불가능 ,
	        마우스 - 장점 : 직관적이다., Pointer and Click 장르   //단점 : 입력까지의 상대적 시간이 버튼, 키보드에 비해 느리다. 
	        조이스틱 -  
	  콘솔 : 게임패드 , 장점 : 진동으로 몰입감을 줄 수 있다. / 편한 자세로 게임을 할 수 있다./ 아날로그식 입력 가능 1 또는 0 이 아닌 0.5  // 단점 : 입력 버튼 갯수가 적다.

	  모바일 : 터치스크린 // 장점 : 학습이 필요 없을 정도로 단순한 조작,    // 단점 : 입력방법 갯수의 제한  /  눌렸는지 안눌렸는지 확인이 불가능/  누를 때 화면을 가린다., / 정확한 조작이 힘듦 (UI 버튼이 작을시 탭이 불편함)


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 5일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	디스플레이
	  - 픽셀(Pixel) - 디스플레이를 구성하는 하나의 점
	  - 도트(Dot) - 인쇄물에서 말하는 하나의 점
		
		PPI (Pixel Per Inch) : 1인치에 포함된 픽셀 수 
		해상도 (Resolution) : 디스플레이로 표현하는 하나의 이미지가 몇개의 이미지를 사용하는지 나타내는 정밀도의 지표 
		 
		  - HD : 1280p, 1280 * 720
		  - FHD(Full HD) : 1080p, 1920 * 1080
		  - 4k UHD(Ultra HD) : 3840 * 2160

		  주사율 : 디스플레이 기기에서 1초에 화면을 몇 번 갱신할 수 있는지를 나타내는 수치 예 60헤르츠  = 1초에 60번 갱신 가능

		컨셉 모델(Concept Model)
		  - 게임의 메인 흐름속에서 서로 영향을 미치는 요소들간의 관계를 표시한 것
		  - 아이디어와 기획을 시각적으로 나타낸 것
		     추상적인 개념들의 관계를 시각화하여 보여주는 것


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 6일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	컨셉모델 

	플로우 Flow
	  - 메인 흐름과 그에 관계된 흐름만 보여주는 것
	  - 전체적인 시작과 끝 사이의 과정을 보여주는 것이 목적

	레이아웃(LayOut)	
	  - 여러 시각요소와 정보(UI)를 효과적으로 전달할 수 있도록 배치 및 설계하는 것
	  - 플레이하는데 필수적으로 필요한 요소들을 적절한 위치에 팝업
		HP 표현방식 : 척수, Vignette
	레이아웃의 구성요소
	  - 통일성 : 재질의 컨셉 : 판타지, SP 등의 요소가 섞여있으면 좋지 않다.
	  - 변화
	  - 균형
	  - 강조

	게임UI 레이아웃의 주요 요소
	  - 장르 적합성
	  - 가시성
	  - 비율, 위치(주요 컨텐츠, 게임 정보) 불편함이 누적되면 게임을 접게 된다.	
	  - 컨텐츠 표시 크기
	  - 모바일 조작 고려



	
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 11일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	평가 풀이
	
	1-1 서로다른 두개 의 시스템이나 장치 ㅇ사이에서 정보나 신로를 주도받는 접점이나 경계면을 무엇이라고 하는가?
		인터페이스

	1-2 화면에 표시되는 그래픽 등을 통해 게임 시스템과 사람간의 상호작용을 가능하게 해주는 것을 무엇이라고 하는가?
		GUI

	2-1 사용자가 어떤 시스템 제품 거비그응 직, 간접적으로 이용하면서 느끼고 생각하게 되는 총체적 경험을 무엇이라고 하는가?
		UX

	2-2 좋은 UX가 주는 장점은 무엇인가?
		사용자의 학습시간을 줄일 수 있다.
	
		갱쟁 컨텐츠가 상당히 많은 요즘 시대에 진입장벽(학습구간)이 높은 컨텐츠를 만드는 것은 진지하게 생각해 볼 필요가 있다.
		
	3-1 PC 게임 플렛폼에서 가장 널이 쓰이는 입력 인터페이스는 무엇인가? 
		키보드 , 마우스
	
	3-2 대부분의 크로스플레이가 가능한 FPS에서 키보드와 마우스를 사용하는 유저와 게임패드를 사용하는 유저를 구분하는 이유가 무엇인가?
		공정성의 문제가 있기 때문 , 패드와 키보드, 마우스의 조작은 난이도의 차이가 있다.

	4-1 키보드의 특정 키와 기능을 바인딩 시켜 빠르게 해당 기능을 사용할 수 있게 하는 것을 무엇이라고 하는가?
		단축키

	4-2 다른인터페이스와 비교해 키보드가 가지는 장점은 무엇인가?
		보급률@@, 키가 많다.

	5-1 마우스가 주 인터페이스인 경우 적합한 게임에는 어떤 것들이 있는가?
		FPS, 포인트 앤 클릭 RTS

	5-2 클릭

	6-1 더블클릭

	6-2 Drag and Drop

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	게임 UI, UX 프로그래밍
		
	RectTransform
	- Transform을 상속받은 컴포넌트. 기본적으로 Transform의 기능에 추가적으로 2D 이미지와 UI에 필요한 기능이 추가된 컴포넌트 
	- 구성요소 : 위치 , 회전, 스케일, 앵커, 피봇, 가로 크기, 세로 크기, 프리셋
		피봇 : 자기 자신의 원점을 어디로 할 것인지  max = 1 , 0.5, 0.5 = 가운데,  : 회전, 스케일은 원점기준
		앵커 : Canvas 의 어느 지점을 기준으로  할 것인지를 기록해 놓은 것

	Canvas, UI가 아닌 일반 오브젝트들이 랜더링 되고난 후 스크린좌표에 덮어쓰는 느낌
	- UI 요소들이 배치될 배경용 컴포넌트 
	- 랜더모드가 ScreenSpace - overLay 일 때 Canvas의 크기는 스크린의 크기와 같다.  
	- 왼쪽 아래가 원점 

	CanvasGroup
	- Canvas 하위의 UI요소들의 Alpha, Interactable, Raycast 를 한번에 설정할 수 있도록 도와주는 컴포넌트

	Event-System
	 - Unity에서 UI관련 입력을 어플리케이션의 이벤트로 전송하는 시스템, 생략시 모든 이벤트의 감지가 되지 않는다.
	 - 이벤트시스템 인터페이스 
		IpointerClick, Enter, Exit, ISelect, Deselect
	
	Layout Group
	- Grid, Vertical, Horizontal Layout Group
	- 이미지와 텍스트, 상호작용의 조합으로 대부분의 UI 조합이 가능하다.
	
	- Image
	  - Raycast Padding - 레이캐스트 될 영역 조절
	  - maskable - 

	- TMP

	- Texsture
	  - 3D 모델의 표면 색상을 저장하는데 사용

	- Sprite 
	  - 2D 그래픽 오브젝트용으로 사용

	빛의 3원색
	  - RGB 컬러를 이용해서 모든 컬러를 표현
	  - 색상 하나를 표현하기 위해 32bit 사용
	  - R, G, B, A 각각 8bit씩 사용 255까지 표현 가능
	  - HDR high dinamic range 사용시 0~ 255 범위를 벗어나게 됨으로 용량이 더 필요하게된다.
	  
	9 - Slicing (9 - Grid)
	  - 이미지를 9개의 그리드로 나누어 이미지의 재사용성을 높이는 기법
	  - 외곽부분은 확대, 축소에 제한을 두는 방식
	  - 외각부분의 비율이나 형태를 유지할 수 있게 해준다.

	상속
	  - 다른클래스에 정의된 맴버(변수 , 함수 , 프로퍼티 등) 을 재사용, 확장 수정하는 새 클래스를 만드는 것 
	  - 상속 해주는 클래스 : 부모, 기본 클래스
 	  - 상속받는 클래스 : 자식, 파생클래스

	  - C# 의 상속 특징 다중상속 불가능, 인터페이스는 가능
	 
	인터페이스
	  - 클래스나 구조체와 관계있는 기능에 대한 정의만 가지는 것
	  - 함수, 프로퍼티만 있음

	다중상속을 막아놓은 이유
	 여러 부모클래스에 같은 이름의 함수, 변수들이 있을 때 혼란을 유발

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 20일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	평가 풀이
	Transform - 행렬 이용
	1-1. 2D 이미지, UI에 사용되는 트렌스폼 컴포넌트 
		RectTransform
	
	1-2. RectTransform의 구성요소
		위치, 회전, 스케일, 피봇, 앵커

	2-1. 캔버스의 x축 y축의 방향은 어떻게 되어있는가
		좌측 하단 기준 오른쪽 : x+, 윗쪽 : y+

	2-2. 캔버스 기본크기
		화면 해상도와 같다.

	3-1. 색의 투명도를 알고싶을 경우 참조할 프로퍼티의 이름 a,(alpha)

	3-2. (0,1,0) 은 무슨 색인가  - 녹색

	4-1. testText.text = "Hello";

	4-2. bold체  testText.text = FontStyle.Bold;

	5-1. 상속

	5-2. 상속받는 클래스를 무엇이라고 하는가
		자식, 파생클래스

	6-1. 클래스나 구조체와 관계있는 기능에 대한 정의만 가지는 것을 무엇이라고 하는가?
 		인터페이스

	6-2. 인터페이스를 상속받았을 때 반드시 해야할 일은 무엇인가?
		- 인터페이스에 정의된 모든 매서드를 구현해야 한다.                         

	
	Mathf.FloorToInt = 올림
	Mathf.RoundToInt = 반올림
	Mathf.Ceil = 내림


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 21일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	게임 네트워크 프로그래밍
	
	네트워크 용어	
	 - 패킷 : 컴퓨터 네트워크가 전달하는 데이터의 형식화된 블록
		구성요소 : 제어 정보, 시작주소, 도착 주소, 사용자 데이터,  패킷의 크기를 적절히 조절해야 한다.

	 - 소켓 : 네트워크상에서 동작하는 프로세스(컴퓨터 단위)간 통신의 종착점(받는 곳, 데이터를 꽂는 끝 지점)

	 - 포트 : 인터넷 프로토콜(IP)  스위트에서 운영체제 통신의 종단점(프로그램 단위). 네크워크 서비스나 특정 프로세스를 식별하는 논리 단위

	
	 - D-Dos공격 = 서버가 수용할 수 있는 량 을 초과하는 패킷을 대량으로 찍어서 날리는 공격	

	네트워크 장치
	 - 허브 : 여러 컴퓨터와 네트워크 장비를 연결하는 장치  네트워크와 컴퓨터의 저장방식이 다름 - 컴퓨터 3 = 0 0 1 1, 네트워크 1 1 0 0 첫번째 비트의 위치가 다름, 그렇기 때문에 변환해주는 작업이 필요함 

	 - 라우터 : 컴퓨터 네트워크간 데이터 패킷을 전송하는 장치, 패킷의 길을 찾아주는 역할 , 패킷을 열보조고 목적지를 확인 한 후 다음 라우터 주소를 정해준다, 전기신호 증폭의 역할도 함

	 - 네트워크 스위치 : 네트워크와 네트워크를 연결하는 통신장비 ,서로 근원이 다른 네트워크간 원활한 통신을 위해 형식 변환을 해주 는 스위치

	 - 게이트웨이 : 같은 네트워크안 에서 서로 다른 통신망이나 다른 프로토콜을 사용하는 네트워크간의 통신을 가능하게 하는 기기


	네트워크 구조
	 - 서버 클라이언트 구조
		- 서버(Server) : 다른컴퓨터(클라이언트)가 요청하는 회선이나 디스크장치에 저장된 데이터장치에 대한 접속을 제어하는 관리 소프트웨어나 컴퓨터  
		- 클라이언트 : 네트워크를 이용하여 서버시스템에 연결되는 사용자

		구조의 특성 : 데이터를 저장하고 관리하는 컴퓨터(서버)	와 해당 컴퓨터에 접속하여 데이터를 열람하는 컴퓨터(클라이언트) 로 구성
			1 : N 으로 구성되는 매우 효율적인 네트워크 구조 // 대부분의 계산이 서버에서 이루어진다
			다수의 사용자들이 공동으로 열람 복사 수정 관리하는 데이터를 한 곳에서 관리할 수 있다.  // 따라서 서버만 잘 관리하면 된다.
			대규모 상호작용이 필요할 경우 매우 적절하다. MMO RPG
			장점 : 효율적 네트워크 구조 . 데이터의 유일성과 통일성을 보장 할 수 있다.   서버와 클라이언트의 데이터가 다를 경우 서버의 데이터를 원본으로 취하면 된다.

			단점 : 해킹, 디도스, 랜섬웨어 등등 서버가 털리면 모두 털리게 된다.  공격타겟이 서버로 명확해 진다.
				각종 보안, 데이터 백업에 많은 비용이 들어간다.
			

	 - Peer To Peer
		중앙, 센터가 없이 네트워크에 참여하는 모든 참여자가 서로 서버이면서 클라이언트가 되는 네트워크 구조			
		
		종류 
		 - 하이브리드P2P 
			기존의 서버 클라이언트 모델을 완전히 벗어나지는 못한 모델.
		 	중앙서버가 존재해서 중재(누구의 데이터를 누구에게 보낼 것인가) 및 검색을 제공

		 - Pure P2P
			네트워크에 참여하는 모든 컴퓨터는 동일한 수준의 책임을 진다.
			장점 : 전체 네트워크가 죽는 일이 거의 불가능하다.
			        네트워크 확장성이 매우 높다(네트워크 증가에 필요한 비용이 제로에 가깝다.)



		 - Host P2P(슈퍼피어) 방을 파서 플레이하는 종류의 게임에 사용되는 구조
			한명이 호스트의 역할을 맡아서 서버의 역할을 한다.
			하이브리드, Pure P2P 의 장점을 모두 갖고있다.
			적합한 게임 : 적은 인원이 같이 플레이, 빠른 액션처리와 정확한 충동처리가 필요한 게임, MO게임

		단점 : 유일성이 보장이 안됨(Hacking), 원하는 데이터를 가진 사람이 없을 수 있다.
		네트워크를 제어할 수 단이 없다. 어떤 바이러스가 퍼질 경우 서버가 있다면 서버에서 차단이 가능하지만 P2P에서는 불가능 하다.
		데이터를 검색할 떄 마다 네트워크의 모든 컴퓨터를 검색해야한다. (시간이 많이 걸린다.) 부하가 매우 커진다. 타인의 컴퓨터내부를 볼 수 있기 때문에 해킹에 취약하다.
			


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 25일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	데이터를 주고받는것 = 전기신호를 주고 받는 것. true or false  

	프로토콜 - 컴퓨터 내부 또는 컴퓨터간 데이터의 교환방식을 정의하는 규칙 체계
	  - 논리적 구성요소
		- 프레임 구성(각 항목의 의미와 기능) 몇 비트~ 몇비트까지 어떤 것을 의미하는지, 자료전송의 절차 

	  - 물리적 구성요소
		- 자료전송에 사용되는 전송매체, disk, ram,CD, 접속용 단자, 밑 전송 신호, 회선 규격

	HTTP - Hyper text transfer protocol
	  - HTML 과 같은 웹 문서를 전달하기 위한 프로토콜

	

	IP - Internet Protocol
	  IP주소 : 네트워크에서 장치들을 구분하고 통신하기 위해 일종의 주소로 사용하는 번호
	  IPv4 : 32bit (0.0.0.0 ~ 255.255.255.255) 약 42억개
		8bit 숫자 4개로 이루어짐
		헤더의 내용 : 버전, 헤더의 길이, 서비스 종류, 전체 패킷의 길이, 분할된 데이터의 몇 번쨰 조각인지, 수명, 체크섬(데이터 손상, 변조 감지), 데이터 출발지, 도착지 주소

	  IPv6 : 128bit (0000.0000.0000.0000.0000.0000.0000.0000 ~ ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff:) 16진수, 16bit 숫자 8개, 너무 길어서 0은 생략 가능
		헤더의 내용 : 버전, Traffic Class, Flow label, Payload length, next header, hop Limit, source IP address, destination IP address


	통신 프로토콜
	 - UDP(user datagram protocol)
		용량이 가볍고 속도가 빠른 대신 신뢰성은 떨어진다.  패킷이 알아서 목적지를 찾아가도록 만들어지는대로 막 보내고 끝
		VoIP 통화, 스트리밍 등 실시간성 보장이 중요한 시스템에서 사용
		
	 - TCP
		신뢰성이 매우 높다.	
		데이터를 안정적이고 순서대로 에러 없이 교환.
		패킷을 보내기 전 도착지까지 경로를 모두 정해준 후 보낸다.(세션 수립)
		게임, 이메일전송이나 파일전송같이 안정성이 중요한 시스템에서 사용 '

	 - TCP 3 way HanShake 
		TCP/IP 프로토콜을 이용해서 통신을 하기 전 정확한 전송을 보장하기 위해 세션을 수립하는 과정
	

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 26일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	정보 보안
	정보보안 핵심 3요소(CIA)
	 - 기밀성 Confidentiality : 정보는 인증된, 허가된 대상만 접근할 수 있어야한다. 누구나 접근할 수 있어서는 안된다.
	 - 무결성 Integrity : 정보의 변경은 허가된 사람이 인가된 메커니즘을 통해서만 이뤄져야 한다.
	 - 가용성 Availablity : 정보는 필요할 때 언제든 사용할 수 있어야 한다. (디도스는 가용성에 대한 공격)

	정보 보안 서비스
	 - CIA(기밀성, 무결성, 가용성)
	 - 인증 Authentication, 허가된 사람이 맞는지 확인하는 시도
		지식 : 비밀번호, 이메일, (특정한 지식을 갖고 있는가)
		소유 : OTP, (특정한 기기를 갖고 있는가)
	 	신체 : 생체인증, 지문 , 홍채, 정맥
	출처를 알 수 없는 이메일, 실행파일, 광고등이 포함된 사이트는 조심해야 한다.

	 - 이단계인증 : 지식, 소유, 신체 중 두가지 이상의 인증 기법을 섞어서 사용하는 것
		범용 OTP를 사용하는 것을 권장.
	 - 부인 방지 : 메세지의 송, 수신 교환 후 또는 통신이나 처리가 실행된 후에 그 사실을 사후에 증명함으로써 사실부인을 방지.  발뺌하는 것을 방지(공인인증서) 인증시 내가 했다는 것을 증명하는 것


	공격기법(고전적인 방식)
	 - 세션 하이제킹 :  - TCP 3 way HanShake 과정 중 로그인된 상태를 가로체서 별도의 인증 없이 시스템이 접근하는 공격(출발지점을 공격자 주소로 바꿔치기함)
	 - SQL(structure query Language) Injection : 악의적인 SQL문을 실행되게 하여 데이터베이스를 비정상적으로 접근하거나 조작하는 코드인젝션 공격 (방지하기 위해 & || 논리연산자를 비밀번호에 포함하지 못하게해야한다.)
	 - DDos : Distributed Deniel of Service : 악성코드, 바이러스로 일반사용자의 PC들을 감염시켜 좀비PC로 만들고 그 PC들이 일제히 접속을 시도하게 하여 서버가 처리할 수 있는 capa 이상의 request를 보내 서버가 마비되게 함
	
	모든 PC의 보안레벨이 동등해야한다 한대라도 구멍이있으면 나머지 보안레벨이 아무리 높아도 의미가 없다.


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
9월 27일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

	HTTP - 패킷 안의 내용을 훤히 들여다볼 수 있음
	HTTPS - 
	에러 검출 - 출발지에서 보낸 정보와 내가 받은 정보가 같다는걸 어떻게 증명할 것인가?
		
	- 패리티 비트 1010 일 때 1의 갯수가 홀수인지 짝수인지 정하고 보내는 것

	 - 체크섬
		데이터를 일정 크기(4bit, or 8bit, or more)로 분리한 다음 그 합계값을비교해서 데이터의 무결성(변했는지) 를 검사한다. 

	 - 해시 함수
		데이터를 정해진 크기의 유니크한, 전혀다른 요약본을 리턴하는 함수
		원본,입력데이터가 약간만 변해도 완전히 다른 결과가 나와야한다.
		원본으로 복구가 불가능하다.
		데이터 무결성 검사에 사용한다.(비밀번호, 파일전송) 파일전송시 파일과 해시결과값을 같이 보내서 수신자가 데이터를 받고 해시를 돌려서 결과값을 비교한다.
		해시충돌 : 서로다른 입렵값을 넣었음에도 같은 출력값이 나온 경우, (해시함수의 수명이 다했다고 판단)
				

		로그인시 서버에 비밀번호를 직접 저장하지 않고 해시알고리즘을 적용한 결과값을 저장해하고 비교해서 처리.

  



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 4일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

	암호화 기법
		특정인물 외 타인이 식별 불가능하도록 하는 기법
		카이사르 시저 알고리즘 => 알파벳 자릿수 밀기
		애니그마 알고리즘

	용어
	 - 평문 (Plain Text) : 암호화되지 않은 데이터
	 - 암호문 (Cipher Text) : 평문을 암호화처리한 데이터
	 - 암호화 (Encryption) : 평문을 암호문으로 바꾸는 처리 
	 - 복호화 (Decryption) : 암호문을 평문으로 바꾸는 처리
		
	대칭키 알고리즘
		데이터를 암호화할 때 특정한 키값을 사용하여 암호화하는 알고리즘
		DES, AES  Data Encryption Standard, Advanced Encryption Standard
		키를 어떻게 전달할 것인가? 하는 문제점이 있다.
		1. 직접전달
		2. 신뢰할 수 있는 제3자를 통하기
		

	
	공개키 알고리즘
		암호화에 사용되는 키와 복호화에 사용하는 키가 서로 다르다.
		개인키, 공개키
		개인키 = 자기 자신만 아는 것
		공개키 = 공개키는 모두가 알고있다.




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 5일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	한쪽방향으로 가긴 쉽지만 반대방향은 그렇지 않은 경우 => Trap Door 방식
	전자서명의 과정 => 특정인의 개인키, 혹은 공개키로 시도했을 때 풀리면 그것은 그 사람의 키로 만들어 졌다는 것을 증명한다.

	공개키 알고리즘 => 소인수분해가 어렵다는 점을 이용한 알고리즘
	
	

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 12일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	평가 풀이
	
	1-1. 컴퓨터 네트워크 간 데이터 패킷을 전송하는 장치를 무엇이라고 하는가
		라우터

	1-2. 네트워크와 네트워크 스위치를 연결하는 통신장비를 무엇이라고 하는가?
		네트워크 스위치

	2-1. 중앙이나 센터가 없이 네트워크에 참여하는 모든 참여자가 평등한 네트워크 구조
		Peer to Peer

	2-2. p2p 구조에서 한 명이 호스트의 역할을 하여 서버의 역할을 하는 방식을 무엇이라고 하는가?
		호스트 p2p

	3-1. 네트워크 통신 프로토콜 중 신뢰성은 떨어지나 용량이 가볍고 송신속도가 빠른 것은 UDP, TCP중 무엇인가 ?
		UDP,   TCP는 순서가 있다.

	3-2. 스트리밍이나 VOIP등 실시간성 보장이 중요한 시스템에서 사용되는 네트워크 통신 프로토콜은 무엇인가?
		UDP, RTP(Real Time)
		
	4-1. 컴퓨터 내부 또는 컴퓨터사이 데이터를 교환하는 방식을 정의해 놓은 규칙체계를 무엇이라고 하는가?
		프로토콜

	4-2. HTML 과 같은 웹문서를 전달하기 위한 프로토콜을 무엇이라고 하는가?
 		HTTP

	5-1.  데이터를 저장하고 관리하는 컴퓨터와 해당 컴퓨터에 접속하여 데이터를 요청하는 네트워크 구조는?
		서버 클라이언트 구조

	5-2. N:1 로 구성되는 매우 효율적인 네트워크 구조로 다수의 사용자들이 동공으로 열람 복사, 수정, 관리하는 데이터를 한곳에서 관리하는 네트워크 구조
		서버 클라이언트 구조

	6-1. 컴퓨터 보안에서 허가된사람이 맞는지 확인하는 시도를 무엇이라고 하는가?
		인증,      기밀성, 무경성, 가용성

	6-2. 인증의 수단에는 어떤 것들이있는가
		지식 : 특정 지식을 보유하고 있는가  비밀번호, 아이디 
		소유 : 특정 기기를 소유하고 있는가  OTP 기기
		신체 : 홍태, 지문, 정맥


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	다음 비트연산의 결과는 무엇인가?
	0x01 << 2  = 0x04, 4, 0b0100

	패리티비트 1010001 짝수 패리티 비트로 만들면?
	11010001  네트워크상에서는 먼저 받는 것부터 처리해야 하기 때문에 왼쪽부터 시작해서 첫번째임, 그러나 컴퓨터 내부 에서는 오른쪽이 첫번째

	세션 하이재킹 공격이란 무엇인가?
	3wayHanshake 에서 송신자의 주소를 공격자의 주소로 바꿔치기 해서 별도의 인증절차 없이 시스템에 접근하는 공격

	프로토콜의 물리적 측면을 구성하는 것에는 어떤 것들이 있는가?
	전송매체, 접속용 단자, 전송신호 , 회선 규격 등

	비트마스킹
	data라는 변수에 저장되어있다고 가정  네번쨰 비트에 1이 셋팅되어있으면 true를 반환하는 코드
	bool result = data & 0b_1000 != 0;
	bool result = data & (1<<3);
	bool result = data & 8 != 0;

	공개키 알고리즘이 나오게된 이유?
	대칭키 알고리즘의 키 배포 문제를 해결하기 위해


	P2P 모델로 만든게임은 핵이나 치트에 매우 취약하다. 그 이유는?
	데이터, 패킷의 유일성 보장이 안되고, 원본이 무엇인지 알 수 없기 때문이다.		


	암호학 분야에서 널리 사용되는 트랩도어 함수란 무엇인가?
	통발
	일방향 함수 입력을 넣었을 때 결과를 도출해내기는 쉽지만   결과를 가지고 입력을 도출해내기는 어렵다. 그러나 트랩도어라는 정보가 있으면 역으로 구하는게 쉽게 되는 함수 


	DDos 공격에 대해 대략적으로 설명하라
	 - destributed deni of service
	악성코드 또는 바이러스 등으로 많은 수의 일반 사용자 컴퓨터를 감염시킨 후 특정시스템의 서비스를 요청하여 시스템의 가용성을 떨어트리는 악의적 공격

	
	p2p 모델을 사용해 게임을 만들었을 때 얻을 수 있는 장점은?
		서버를 거치지 않아도되서 빠른 처리가 가능하다.  ex) 클라 - 서버 - 클라 // -> 클라 -> 클라
		인원수가 적기 때문에 더 높은 퀄리티의 그래픽을 랜더링 할 수 있다.

	공개키 알고리즘에 대해 설명하라.
		개인키와 공개키로 이루어져 있다.
		개인키는 자기 자신만 알 수 있다.
		공개키는 모두가 알고있다.
		개인키로 암호화한것은 공개키로 복호화 가능(전자서명용)
		공개키로 암호화한 것은 개인키로만 복호화 가능(암호화용)

	서버클라이언트 모델의 장단점을 설명하시오
		장점 : 효율적인 네트워크 구조, 데이터의 유일성과 통일성 보장
		단점 : 각종 공격에 타깃이 서버로 명확해진다. 공격을 방지하기 위한 보안제품 설치와 데이터백업에 많은 비용이 들어간다.
	


	

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 12일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	웹 서버
	 - 주로 사용하는 프로토콜 -> http = html 문서와 같은 웹페이지를 반환하는 컴퓨터 프로그래밍이나 컴퓨터 
	 - 주요기능 : http 요청 처리, 데이터 로깅(누가 언제 뭘 했는지, 언제 어떤 요청이 왔는지)
	 - 기타기능 : 인증, Https 지원(특징 : 출발지점과 도착지점을 숨김, 하이재킹 방지), 컨텐츠 압축, 
			대역폭 스로틀링(반도체는 정상 작동 온도가 있음, 따라서 발열때문에 사용제한을 걸어둠 제한을 걸어두는 것 = 스로틀링), 한사람이 너무 많은 서버의 대역폭을 사용해서 다른사람이 서비스를 받지 못하는 상황을
			방지하기 위함

	HTML
	 - Hypertext markup language : 하이퍼텍스트 구조를 정의하기 위한 언어
	 - 웹 컨텐츠의 의미와 구조를 정의할 때 사용하는 언어
	 - 웹을 이루는 가장 기초적인 구성 요소
	 - 태그를 통해 HTML 각 요소를 구분(<>로 붂여있음)  <#00ff0000></color>

	 웹 브라우저
	 - 웹 서버에서 이동하며 쌍방향으로 통신하고 HTML문서나 파일을 출력하는 GUI기반의 소프트 웨어
			 
	반응형 웹 디자인 : 모바일 인터넷이 활성화 되면서 너무 많은 해상도에 하나하나 모두 대응하기 힘들기 때문에 만들어짐
			하나의 웹 사이트에서 웹브라우저의 해상도에 따라 컨텐츠의 크기와 위치가 자동으로 변하도록 만든 웹페이지 접근 기법


	

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 17일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	c# 의 네임스페이스들
		
	System.Net.Http
	 - HTTP 용 응용 프로그램밍 인터페이스를 제공하는 네임스페이스
	 - 핵심 클래스
		httpClient
		HTTP를 통한 리퀘스트를 요청하고 받는 기본클래스. 새션의역할을 한다.

		
		System.Text.Json   //Jason- 자바스크립트에서 파생된 포맷
		Json용 응용프로그램의 프로그래밍 인터페이스를 제공하는 네임스페이스
		JsonSerializer : c# 객체와 Json 문자열릏 서로 변경하는 기능을 제공하는 클래스 ,
		JsonDocument : Json문자열을 일부만 사용하기 위해 json Document Object Model로 사용할 수 있게 해주는 클래스

		System.Security.Cryptography : 암호화알고리즘이나 해시 알고리즘을 제공하는 네임스페이스

	Unity 네트워크 지원
		Unet -> Mirror
		photon - 가장 일반적으로 사용되는 네트워크 라이브러리

		NetCode for gameobject : 최소 지원버전 2021.3
		 - NetworkManager : 유니티에서 모든 네트워킹 관련 설정이나 네트워크용 프리팹이나 관련 씬에 대한 핸들링을 위한 컴포넌트 
		 - NetworkObject : 네트워크를 통해 오브젝트를 리플리케이트 시키기 위해 필요한 컴포넌트. Spawn을 통해 생성
		 - NetworkTransform : 네트워크를 통해 트렌스폼을 실시간으로 동기화 시키고 싶을 때 사용
		 - NetworkAnimator : 네트워크를 통해 애니메이션을 동기화 시키고 싶을 때 사용 
		




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 17일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	위협 - Thread : 잠재적 손실이나 손상의 원인이 될 가능성이 있는 환경
		ZeroDay Attack - 발매 당일 공격을 가하는 것  이미 알려진 취약점을 공격가는 것 ex) 특정 엔진을 이용해 만들어 졌다면 

	취약점 - vulnerability : 위협에 의하여 손실이 발생하게 되는 자신의 약점, 공격당할시 아픈 곳
		buffer overFlow 

	위험 - Risk : 예상되는 위협에 의해 취약점을 공격당해서 유, 무형의 자산에 발생할 수 있는 손실의 예상치.
			만약 100만원의 리스크가 있는데 위협을 막기위해 투자해야하는 금액이 1000만원 일 때와
			10만원 일때 대처는 달라질 것이다. 따라서 리스크 산정이 중요해진다.

	공격
	 - 위협과 취약점을 통해 피해를 입히는 행위
              	 - 브루트 포스(무차별 대입 공격), 근본적으로 막을 방법이 없음, 늦게 풀도록 처리해서 방지 ex/ 일정횟수 이상 틀리면 일정시간동안 시간제한을 두게된다.
		비밀번호를 길게 입력하게 하는 추세, 어차피 해시알고리즘을 돌리면 일정한 값으로 저장이 됨.
	 - XSS(크로스 사이트 스크립팅)	게시판같은 곳에 페이지를 여는 순간 자동으로 실행될 스크립트, 영상 등을 삽입하는 행위
		ActiveX, Flash, 

	 - SQL Injection(SQL 인젝션) : 코드인젝션 공격 기법중 하나로 ID 와 비밀번호를 입력하는 란에 모든 조건을 참이되게 만드는 SQL 쿼리문을 넣어 권한을 탈취하는 공격방식
	 - Human Error : 회사주변 꽂는 순간 감염되는 USB 를뿌리는 등


	공격방어법
	 - Two Factor Authentication(두 요소 인증)
		인증을 할 때 한번에 두 종류의 인증 매커니즘에 성공적으로 통과했을 때만 인증에 성공한 것으로 간주하는 접근 제어기법
	 - OTP 높은 수준의 보안 요구에 의해 한번의 인증 당 하나의 임시 비밀번호를 사용하는 방식

	 - 공용PC 및 USB 사용시 Defender를 돌리는 것을 추천	 

	방어 방법

		

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 24일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	평가풀이

	1-1. HTTP 요청을 받아서 문서와 웹페이지를 반환하는 프로그램이나 컴퓨터 
		웹서버
	
	1-2. 1-1 이 공통적으로 제공하는 기본적인 기능은 무엇이 있는가
		HTTP 처리, 데이터 로깅

	2-1. 웹을 이루는 가장 기초적인 구성요소로 웹 콘텐츠의 의미롸 구조를 정의할 때 사용하는 언어는 무엇인가
		HTML

	2-2. HTML 의 각 요소는 무엇으로 구분되는가 <>
		Tag

	3-1. HTTP용 응용 프로그램의 프로그래밍 인터페이스를 제공하는 네임스페이스
		System.Net.Http

	3-2. Json 응용프로그래밍 인터페이스를 제공하는 네임스페이스
		System.Text.Json
		

	4-1. HTTP 를 통한 리퀘스트를 요청하고 받는 기본클래스는 무엇인가?
		HTTPClient, UnityWebRequest

	4-2. 4-1 의 클래스 인스턴스는 HTTP 리퀘스트에 대해 어떤 역할에 가까운가
		세션

	5-1. Unity 에서 네트워크지원을 위해 사용하였으나 현재 지원이 중단된 라이브러리
		Unet

	5-2. 유니티에서 현재 네트워크지원을 제공하는 라이브러리의 명칭은?
		Netcode for GameObject

	6-1. Netcode를 지원하는 Unity의 최소 버전은?
		Unity 2021.3

	6-2. Netcode를 공식적으로 지원하지 않는 플랫폼은?
		WebGL 이었으나 현재는 지원하고있다.


게임이 느린 이유는 
연산량이 많기 때문
텍스쳐, 폴리곤 등 

Batches - DrawCall를 줄여야한다
Saved by batching 이 클수록 좋다
머티리얼 하나당 batches  하나


최적화

프러스텀컬링 - 카메라의 각 안에들어온 것들만 활성화

오클루젼 컬링 - 당장 보이는 물체만 활성화

LOD  - Level of Detail
거리에 따라 다르게 처리

LODGroup 컴포넌트 
숫자가 작을수록 가까이 있는것
culled는 안보이는 것



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 25일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	게임 데이터베이스 프로그램


	데이터 - 측정이나 수집을 통해서 수집한 단순 자료

	정보 - 목적이나 의도에 따라 처리하고 분석하여 가공된 데이터, 데이터에 의미를 부여한것

	데이터베이스 
	 
	 - 특정 조직 내에서 다수의 사용자가 사용할 수 있도록 통합하여 저장한 운영 데이터의 집합
		
	 - 관계형 데이터베이스 Relational DataBase
		키값을 이용해 테이블간의 종속성을 관계로 표현한다.

		데이터를 테이블 형태로 저장한다.   
		테이블 : 행과 열로 짜여진 표에 기록된 데이터의 집합.
			행 : Row,     Record // 논리적으로 연관된 필드의 집합
			열 : Column, Field // 가장 작은 단위의 데이터 

			도메인 : 필드의 데이터 타입에 맞는 필드가 가질 수 있는 값들의 집합   예 > 나이 = 8비트 / 
			키 : 데이터베이스에서 레코드를 구별할 수있게 해주는 식별자   	      예 > 주민등록번호
			기본 키 : 테이블에 있는 모든 레코드를 식별할 수 있게 해주는 필드 중에서 대표로 선택된 것


	
	
		테이블의 구성요건
		테이블의 레코드는 유일해야 한다.		
		테이블의 레코드들 간에는 순서가 없다.  // 굳이 중요하지 않다.   
		테이블의 필드들 간에도 순서가 없다.  // 굳이 중요하지 않다.

	
	
	데이터베이스 언어 (쿼리 랭귀지)
	 - 데이터베이스의 구조 정의, 데이터 조작(읽기, 쓰기), 데이터 보호나 복구를 위해 사용되는 언어

		쿼리랭귀지의 종류
	 - 데이터 조작어 DML(Data Manipulation Language) : DB 조회, 검색, 변경   (SQL)
	 - 데이터 정의어 DDL(Data Definition Language) : 테이블 생성, 변형, 삭제
 	 - 데이터 제어문 DCL(Data Control Language) : 관리자용(권한부여 및 회수)

	데이터베이스의 성질(ACID)
	 - Atomicity(원자성) : 근본. 더이상 쪼개지지 않는 기본 단위, Transaction 트렌젝션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않아야 한다.
				될려면 되고 안되면 안되야한다.
	 - Consistency(일관성) : 트렌젝션 이후 데이터베이스의 상태가 일관되어야 한다. DB의 제약이나 규칙에 맞아야 한다.  ex> 주민번호는 앞 6자리 뒷 7자리

	 - Isolation(격리성) : 모든 트렌젝션은 다른 트렌젝션으로부터 독립적이어야 한다.
				다른 트렌젝션에 영향을 받아서는 안된다.

	 - Durability(지속성) : 성공적으로 트렌젝션이 수정되면 영원히 반영되어야 한다.  트렌젝션을 통해 값을 변경한 후 이유없이 값이 변경되서는 안된다.



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 26일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	DBMS(Database Management System)
	 - 데이터베이스를 생성하여 안정적이고 효율적으로 운영하는데 필요한 기능을 제공하는 소프트웨어
	
	DBMS 의 종류
	 관계형 데이터베이스
  	 계층형 데이터베이스
	
	파일File
	 - 데이터를 저장매체에 기록해 놓은것 단위 
	 - 종류 : 실행파일, 텍스트, PNG, MP3 
	 - 확장자 : 로 구분. GUI를 이용하는 운영체제를 사용하면서 아이콘으로  표현이 가능해졌다.  어디까지나 표시용도이다. 확장자를 바꾼다고해서 파일의 내용이 바뀌지는 않는다.

	저장위치
	 - 물리적 위치 : 디스크에서의 위치, HDD, SSD 
	 - 논리적 위치 : 디렉토리, 폴더,, //  세이브 로드 = 노가다 

	텍스트 파일
	 - 컴퓨터 파일 시스템에서 사람이 알아볼 수 있는 문자열을 저장하는 파일 유형
	 - 스크립트도 일종의 텍스트파일 중 하나이다. 그렇기 때문에 텍스트파일과 호환이 가능하다.

	사람의 눈으로 봤을 때 구분이 불가능한 것들을 저장 ex/ space 4번, tab 한번
	 탭 \t, 줄바꿈(개행문자) \n, \r,  LF CR
		\n : Line Feed 커서를 한줄 아래로 내린다.
		\r : Carrige Return  커서를 줄의 맨 앞으로 옮긴다.
		
	CSV(comma - Seperated - values)
	 - 필드를 콤마같은 구분문자를 사용하여 구분

	JSon - JavaScript Object Notation , 자바스크립트에서 파생된 
	역시 기본적으로 텍스트파일, 구조화된 데이터를 표현하기 위한 문자 기반의 경량포멧


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 26일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ               - 바이트스트림으로 저장한 것은 사람이 알아볼 수 없다.
- 문자 인코딩
	- 사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 변경하는 것
	- 저장했던 것과 같은 방법의 디코딩으로 열어야 내용을 알아볼 수 있다.
- ASCII - American Standard Code for Information Interchange
	- 미국 표준협회 ASA에서 개발한 영문 알파벳을 사용하는 가장 기본적인 문자 인코딩 방식 문자를 표현하기 위해 7bit 사용
	
- 인코딩 방식이 각 나라마다 다를경우 호환이 안되기 때문에 "유니코드" 라는 것이 만들어짐
- Unicode
	- 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준
	- ANSI -아스키
	- UTF16

 - UTF8 
	 - 유니티는 UTF8을 지원 EditorConfig 에서 설정 가능
	 - 유니코드 인코딩 방식 중 하나
	 - 글자 하나를 표현하기 위해 1~ 4byte의 가변 길이를 사용한다.
	 - 장점으로 ASCII 코드가 포람이 되어있어 완전한 하위호환성이 보장된다.
	 - 인코딩을 하는데 비트연간만 사용되어 속도가 빠르다

- C# 파일 읽고 쓰기
	- using System.IO : 파일을 읽거나 쓰는데 사용되는 네임스페이스
	- class File
		- 단일파일에 대한 만들기, 복사, 삭제, 이동, 열기 등을 위한 정적static 메서드 제공
		- FilrStream 개체 만들기를 지원.
		
	- StreamReader
		- 특정 인코딩의 바이트 스트림에서 문자를 읽는데 사용하는 클래스
	- StreamWriter 
		- 특정 인코딩의 바이트 스트림에서 문자를 쓰는데 사용하는 클래스

	- string read = File.ReadAllText(@"txt.text")
		- C#에서는 @를 앞에 붙히면 폴더의 경로를 나타내기로 약속
	- string write = File.WriteAllText("test.text", "Hello World");

-  파싱 Parsing
	- 일련의 문자열에서 특정 패턴이나 순서를 파악해 의미있는 토큰을 추출한 후 토큰에서 데이터를 받아오는 행동
		- HP, EXP, STR, DEX, INT, 
	- 유용한 string 함수들
		- Trim
			- test = test.Trim(); 
			- "asd asd    " => "asdasd"
		- SubString
			- string a = "12345"
			- string b = a.SubString(2);
			- b = "345"
		- IndexOf
			- int index = a.IndexOf('4');
			- index = 3;

- 파서 Parser
	- 파싱작업을 하는 프로세서



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
10월 30일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ     

마크업 언어
- 문자나 데이터의 구조를 명기하는 언어
- HTML, XML(extensible Markup Language)

 XML
 - 인터넷으로 연결된 서로 다른 종류의 시스템끼리 데이터를 쉽게 주고 받기 위해 만들어진 언어


PlayerPrefs
- 플레이어의 기본적인 설정을 저장하는 클래스
- 그러나 저장 위치가 유니티 레지스트리 폴더에 저장되어 모두 오픈되어있기 때문에 데이터가 쉽게 변조될 수 있어 가급적 사용하지 않는 것이 좋다




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
11월 2일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ     
1-1 측정이나 수집을 통해 단순 수집한 원시자료를 무엇이라고 하는가?
- 데이터

1-2 수집한 데이터를 목적이나 의도에 따라 처리하고 분석하여 데이터에 의미를 부여한 것을 무엇이라고 하는가?
정보

2-1, 특정 조직 내에서 다수의 사용자가 공유할 수 있도록 통합하여 저장한 운영 데이터의 집합을 무엇이라고 하는가?
DBMS   DataBase Management System

2-2. 컴퓨터 파일시스템에서 사용하는 차일 중 사람이 확인할 수 있는 문자열을 저장하는 파일유형을 무엇이라고 하는가? 
- 텍스트 파일

3-2 사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 변경하는 것을 무엇이라고 하는가?
- 문자 인코딩

4-1. 미국 표준협회ASA 에서 개방한 영문 알파벳을 사용하는 가장 기본적인 7bit  문자 인코딩은 무엇인가? 

4-2 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준을 무엇이라고 하는가?
- Unicode

5-1. PlayerPrefs 의 주된 기능은 무엇인가?
- 플레이어의 기본적인 설정을 저장하고 불러오기

5-2 윈도우에서 PlayerPrefs 를 저장하는 곳은 어디인가?
- 레지스트리

6-1. PlayerPrefs 를 이용해 HP 라는 키값으로 50.5를 저장하는 코드를 작성하라
- PlayerPrefs.SetFloat("HP", 50.5f);

6-2 PlayerPrefs 를 이용해 MP 라는 키값이 존재하는지를 확인하여 해당키값이 있다면 true, 없으면 false를 result 에 저장하는 코드를 작성하라

- bool result = PlayerPrefs.HasKey("MP");



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
11월 3일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ   
11월 9일 이수자 평가

분석 - 시장분석, 사용자, 경쟁자분석,  신뢰할수 있는 자료

평가 - 차별화요소

아이디어 발생방법 - 브레인스토밍
일단 꺼내고 말이 되는 것들을 정리하는 기법



기획 스토리, 배경,  상상력을 구현할 수 있는 기술적 요소


게임 알고리즘
- 벡터 
	- 힘의 크기와 방향을 표현하는 방법
	- 방향 = x, y, z 
	- 크기 
	- 단위벡터(유닛벡터) 길이가 1만 남긴 것이기 때문에 방향만을 표시할 수 있음
	- 외적 - 두 벡터의 외적  앞쪽과 뒤쪽을 구분할 수 있게되고   렌더링에서 뒷쪽은 그리지 않아도 되기 때문에 성능적으로 이득이 있다.
	- 내적

- 행렬
	- 곱하기의 교환법칙이 성립하지 않는다.( a * b와  b * a 의 결과가 같지 않다.)
	- 쿼터니언 오일러앵글의 짐벌락 문제점을 해결하기 위해 등장  행렬은 16개를 저장해야하는 반면 쿼터니언은 4개만 저장하면 된다.

- 충돌처리
	- 물체가 충돌했는지 안했는지 판단하기 위한 방법
	- 두 물체의 중심점 거리가  두 물체의 반지름의 합 보다 크면 충돌하지 않았다. 
	- 모든 삼각형의 충돌처리를 계산하려면 계산량이 너무 많아지기 때문에 콜라이더라는 충돌영역을 따로 사용하게 된다.

- 비트연산
	- &, |, <<, >>    & = 셋팅되어있는지 확인 또는 셋팅해제 할 때 사용, | 셋팅할 때

- 보간 - 시작값과 끝 값이 주어졌을 때 중간 값을 계산하는 기법

- C# 값타입, 참조타입
	- Value Type - struct - 스텍에 저장
		- 깊은복사 값타입의 데이터를 새롭게 완전히 복사하는 것
		- 원본 데이터의 변형이 없고 시간이 느린 편이다.
	- Reference Type - class - 힙에 저장
		- 얕은 복사 - 주소만 저장할 수 있는 공간만 만들고 참조의 주소만 저장하는 것

- 자료구조
	- 배열 - 랜덤엑세스가 빠르나  크기를 동적으로 변경할 수 없다.
	- 리스트 - 고전적인 의미의 리스트는 랜덤엑세스가 느리나 내부적으로 배열을 만들어 속도를 개선했다.
	- 트리 - 1대 N 계층 구조를 갖고있다. 
		- 2진트리 자식이 최대 2개
	- 큐 - 선입선출
	- 스텍 - FILO 선입후출
	- 딕셔너리 - 
	- 해시셋
	- 그래프 N : N 구조

- 알고리즘 - 문제를 해결하기 위한 절차를 설명한 것
	- 시간복잡도 - 알고리즘을 실행 할 때 데이터 갯수에 따라 걸리는 시간을 BigO표기법으로 표시한 것
	- 공간복잡도 -  알고리즘을 실행 할 때 필요한 메모리의 양

- 게임엔진
	- 게임을 만들기 위한 툴, 라이브러리를 모아놓은 것
	- 유니티의 특징 - 멀티플렛폼 지원

- 유니티 이벤트 함수
	- Awake - 오브젝트가 만들어진 직후
	- Enable - 만든 이후 활성화 될 때 마다
	- Start - 첫 번째 Update프레임이 시작되기 직전
	- Update 
	- FixedUpdate - 업데이트주기를 일정하게 조정할 수 있음 물리처리할 떄 사용
	- LateUpdate - 카메라, 모든 오브젝트들이 다 움직인 후 카메라 랜더
	- Collision, Trigger
	- DrawGizmo
	- AddListner

- 씬은 오브젝트로 구성되어있고 오브젝트는 컴포넌트로 구성되어있다.
	- 


- 3D 수학 좌표계
	- 축을기준으로 물체의 위치를 기술하는 좌표계(데카르트 좌표계)
	- 왼손 좌표계    z축이 앞쪽으로 나감 , 윈도우 DirectX 플렛폼에서는 왼손좌표계
	- 오른손 좌표계   z축이 내쪽으로 , OpenGL
	- 월드좌표계  -  위치를 표현하기 위한 원점이 월드기준
	- 로컬좌표계  -  위치를 표현하기 위한 원점이 오브젝트 기준
	- 스크린좌표 - 위치를 표현하기 위한 원점이 디스플레이 기준, 픽셀단위로 계산

- 랜더링 파이프라인 - 3D오브젝트로 구성된 월드를 2D이미지로 변환하는과정
	- 월드변환 - 오브젝트의 로컬좌표를 월드좌표로 바꾸는 것
	- 카메라 변환 - 월드변환된 좌표를
	- perspective - 원근투영
	- authoGraphic - 직교투영
	- 

 - Ray - 특정 지점에서 특정 방향으로 나아가는 것  위치와 벡터(방향) 이 필요
 - 벡터는 방향을 나타내기도하고 위치를 나타내기도 한다.
 - Line - 특정 점과 점 사이를 이은 것, 시작점과 끝 점이 존재

- VR  양안시차, 카메라 두개를 이용해 3D 가상 세계를 표현하는 것
	- 헤드트레킹 등 이용


- 게임 클라이언트  프로그래밍

- C#
	- 객체지향 언어
		- 접근제한자
			- public 어디서든 접근 가능
			- protected 상속받은 클래스만 접근 가능
			- private 자기 자신만 접근 가능
		- 상속 : 특정 클래스의 멤버를 물려받는 것 C#은 다중상속을 지원하지 않는다.
			- 오버라이드한 함수가 양쪽 부모에 모두 존재할 경우 어떤 함수를 호출해야할지 컴파일러가 알 수 없음
		-  인터페이스
			- 인터페이스가 실행할 수 있는 행동(함수)만 기록해 놓은 것(구현은 상속받은곳에서 구현) 이름, 리턴타입, 파라미터 등 바디를 제외한 것들을 구현

	 -  가비지 콜렉터	
		 - 힙에 있는 것들 중 참조의 카운트가 0이된 객체들을 수거해 가는 것
		 - 스텍에 있는 것들은 함수가 종료되면 모두 사라지기 때문에 콜렉터가 수거하지 않는다.
		
	 - 이벤트  
		 - 프로그램이 감지할 수 있는 것
		 - 이벤트드리븐

	- 예외 (Exeption)
		- 프로그래머가 예상치 못해서 설정하지 않은 부분
		- 프로그램은 더이상 실행할 것이 없을 때 끝나게 되는데 예외의 경우가 생기면 더이상 실행할 수 없는 상태가 되기때문에 터지게 된다.

	- 


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
11월 6일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ   

- 유니티
	- 씬
	- 게임오브젝트
		- 이름 - Find
		- 타입 - FindObjectOfType, FindObjectWithTag, AnyObjectByType
	- 컴포넌트
		- GetComponent

- 터레인
	- 커다란 지형을 표현하기 위한 방법
	- 높이맵 사용
	- 적은 메모리로 넓은 지형 표현 가능
	- 지형구조가 단조로울 수 밖에 없다. 급경사, 동굴등

- 유니티 특수폴더
	- Editor
		- 런타임중 실행되는 것이 아닌 에디터상에서 작동하는 스크립트
	- Resources
	- StandardAsset

- 유니티의 입력방식
	- InputManager
		- 전통적인 유니티의 입력 방식
		- busyWait 발생
		- Polling 방식
		- 배터리소모 심함
	- InputSystem
		- 새롭게 추가된 입력처리 방식
		- EventDriven

- 유니티 에니메이션
	- 메카님 : 애니메이션시스템
	- 주요 컴포넌트 : Animator 
	- 주요에셋 : Animator Controller, Animation Clip, Avatar(본의 맵핑정보)
	- 3D 오브젝트의 정점의 위치를 기록해 빠르게 보여주는 것
	- 애니메이션 본
		- 모든 정점의 위치변화를 기록하는 것은 너무 비효율적이기 때문에 등장
		- 가상의 뼈를 만들어서 뼈가 움직 일 때 연결된 정점들을 같이 움직이게 한다.

	- 애니메이션 리타게팅
		- 본 이름과 갯수가 같으면 굳이 같은걸 또 만들지 않고 재활용 가능하게 해줌

- 유니티 씬 관리
	- SceneManager
		- LoadScene 동기방식 : 반드시 앞에것이 처리되고 나서 처리, 로딩중에는 아무것도 하지 않는다.
		- LoadSceneAsync 비동기방식 : 병렬처리 - 로딩중에 다른작업도 실행한다.
		- LoadSceneMode.Additive, LoadSceneMode.Single - 씬을 어떻게 로드할 지
			- single - 이전씬의 오브젝트, 정보를 모두 삭제한 후 새 씬 로드
			- Additive - 현재씬에 다음 씬의 정보를 추가로 로드할 때
		- 심리스SeamLess
			- 플레이어가 볼 수 있는 맵과 , 볼 가능성이 있는 맵만 계속 유지하는 맵 로딩 방식
			- 볼 가능성이 없어진 맵은 로딩 해제

- 리지드바디
	- 물리를 적용할 수 있도록 해주는 컴포넌트
	- 움직이는 물체에 콜라이더가 있으면 반드시 rigidBody가 있어야 한다.
	- Kinematic - 물리를 적용 하되 움직이는 것은 스크립트로만 조작하고싶을 때 


- 인공지능
	- 인간의 지능을 인공적으로 구현하려는 컴퓨터 과학의 분야
	- 약 인공지능 - 정해진 Input과 Output 에의한 상호작용만 가능
	- 강 인공지능 -  AGI (**Artificial General Intelligence**) 인간과 비슷하거나 더 나은 행동을 하는 인공지능
	- 초 인공지능 - 인간을 아득히 초월한 인공지능

	- 인공지능의 활용분야
		- GPT - 자연어처리
		- 빅스비, siri
		- 전문가 시스템 - if, else 의 연속
		- 머신러닝 
		- 길찾기
		- DLCC
		- 업스케일링시 픽셀이 깨지는 것을 계산해주는 것

		- 유한상태기계
		- BehaviourTree

		- Astar 
			- 휴리스틱 함수를 사용한다.
			- F(x) = g(x) + h(x)
		- 네비게이션 메시
			- 지형을 그래프로 표현하기 위해 폴리곤의 집합으로 변경한 매시
			- NevMeshAgent - 네비게이션 메시 위에서 움직이기위해 추가해야하는 컴포넌트
				- 안움직이는 물체와는 충돌체크를 할 필요가없음
				static으로 설정 필요


- 네트워크
	- 패킷 : 네트워크가 전달하는 데이터의 형식화된 블럿
	- 소켓 : 프로세스간 통신의 종착점
	- 포트 : 운영체제 통신의 종단점, 프로세스를 식별하는 논리단위

- 네트워크 구조
	- 서버 클라이언트 구조
		- 클라이언트들의 요청을 체크하고 데이터를 제공하는 서버와 클라이언트들로 이루어진 구조
		- 장점 : 1: N 구조 데이터 관리가 한 곳에서 이루어져 데이터의 유일성이 보장이됨
		- 단점 : 공격의 타겟의 명확해지고 관리비용이 많이든다.
		
	- P2P  구조
		-  N : N 구조
		- 장점 : 규모 확장에 비용이 거의 들지 않는다, 속도가 빠르고, 모든 Peer가 다운되지 않는 한 서버가 죽지 않는다.
		
		- 단점 : 데이터의 유일성이 보장되지 않음

		- 프로토콜
			- 데이터 교환을 어떻게 할 것인지에 대한  규약, 규칙 체계
			- 논리적 구성요소 : 몇 bit~ bit 까지 어떤 정보를 담는가 등
			- 물리적 구성요소 : 회선규격, 단자, 저장매체
			- HTTP
				- HTML 을 주고받기 위한 프로토콜
			- IP 인터넷 프로토콜
				- V4  32bit, 
				- V6  128bit
			- 통신 프로토콜
				- TCP
					- 세션수립(3way Hand Shake)을 하는데 시간이 걸림
					- 안정적이다. 순서대로 패킷의 경로를 모두 정한 후 차례대로 보낸다.
					- UDP에 비해 시간이 다소 더 걸린다.
					- 은행 등 금융기관에 이용
				- UDP
					-  만들어지는 즉시 뿌려서 신뢰성은 낮지만 속도가 빠르다.
					- 영상, 게임 등에 이용

	- 정보보안 
		- C  기밀성
		-  I  무결성 
		- A  가용성 - 정보는 필요할 때 언제든 사용할 수 있어야 한다.

		- 정보보안 서비스
			- CIA, 인증, 부인방지
			- 인증 - 이 정보에 접근이 허가된 사람인지 확인하는 과정
				- 생체기반
				- 소유기반
				- 지식기반
			
			- 부인방지 
				- 오리발 금지하는 것
				- 전자서명 공인인증서
					- 공개키
					- 개인키
					- 개인키로 암호화 한 것은 공개키로 복호화 가능하고 
					- 공개키로 암호화 한것은 개인키로 복호화 가능하다.

	- 세션 하이재킹
		- 다른 사람의 인증 절차의 세션을 가로채서 마치 내가 인증 한 것 처럼 속이는 것
	- DDos
		- 다수의 컴퓨터를 감염시켜 패킷을 마구 보내 서버의 가용성을 모두 소진시키는 공격

	- 에러 검출
		- 패킷 손상
		- 패리티 비트
			- 보내질 패킷의 1로 세팅된 비트가 짝수, 혹수인지 미리 약속 후 보내는 것
		- 체크섬
			- 데이터를 모두 쪼개 더한 것을 뒤에 붙여서
		- 해시 함수
			- 어떤 인풋을 주더라도 유니크한 아웃풋이 나와줘야 한다.
			- 약간의 변화로도 완전히 다른 결과가 나와야 한다.
			- 결과를 가지고 인풋을 알아낼 수 없어야 한다.
			- 서버측에서 비밀번호 관리할 때 사용. 절대 원본을 저장하지 않는다.
		- 해시충돌
			- 아웃풋이 겹치는 경우

	- 암호화 할고리즘
		- 대칭키
			- 암호화, 복호화에 같은 키를 사용한다.
			- 암호화, 복호화하는 쪽 모두 키를 갖고 있어야 하는데 이 키를 어떻게 배포해야 하는가 하는 문제가 있음
		- 공개키
			- 암호화의 키와 복호화용 키가 다르다.
			- 공개키로 암호화시 개인키로 복호화
			- 개인키로 암호화시 공개키로 복호화
		- TrapDoor 함수
			- 특정 방향으로 가긴 쉬운데 반대방향은 어렵게 해 놓는것
			- 어떤 키를 알고있으면 다시 반대쪽으로 가기 쉬워지는 것


- 웹 프로그래밍
	- 웹 서버
		- HTTP 요청을 처리하고 각종 웹페이지를 반환하는 컴퓨터나 프로그램
		- HTML 
			- 마크업 언어
		- 웹 브라우저
			- 웹서버와 쌍방향 통신하고 각종 문서나 파일을 출력하는 GUI 기반 소프트웨어 
			- 크롬, 엣지, 
		- 반응형 웹

	- 공격
		- 위협
			- 실현되지 않은 가능성
		- 취약점
			- 약점, 공격당할 시 손실이 예상되는 곳
		- 위험
			- 손실의 예상치
		- 자산
		- 경제적 가치가 있는 유 무형의 재산

	- 무차별 대입 공격 

	- 데이터
		- 정제되지 않은 것
	- 정보
		- 데이터에서 필요한 것을 뽑아낸 것

	- 데이터베이스
		- 특정 조직 내에서 조직의 구성원들이 사용할 수 있도록 통합해서 저장한 운영데이터의 집합
		- DBMS
			- 데이터베이스를 생성하여 안정적이고 효율적으로 운영하는데 필요한 기능을 제공하는 소프트웨어
		- 데이터베이스 언어
			- 쿼리랭귀지
				- 데이터 조작어 DML
				- 데이터 정의어 DDL
				- 데이터 제어문 DCL
		- 데이터베이스의 성질
			- Atomicity 원자성
			- Consistancy 일관성
			- Isolation 격리성
			- Durability 지속성
		- 테이블
			- 세로줄과 가로줄의 모델을 이용하여 정렬된 데이터 집합
			- 구성요건
				- 레코드는 유일해야한다.
				- 레코드들과 필드들간에는 순서가 없다.

		- 텍스트파일
			- 사람이 확인할 수 있는 문자열을 저장하는 파일 유형
			- CSV Comma Separated Value, Json
			- 문자인코딩
				- 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 변경한 것
				- ASCII - 영어만
				- Unicode -전세계 언어 통합
			- 파싱
				- 일련의 문자열에서 특정 패턴이나 순서를 파악해 의미이는 토큰을 추출한 후 토큰에서 데이터를 받아오는 행동

		- PlayerPrefs
			- 유니티에서 제공하는 텍스트 파일




ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
11월 9일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ   
게임 플랫폼 응용 프로그래밍

- 플렛폼
	- 소프트웨어가 구동 가능한 하드웨어 아키텍쳐나 소프트웨어 프레임워크의 종류
		- Windows, Android, IOS, XBOX, PlayStation, Nintendo, Steam

- 멀티플렛폼(크로스플렛폼)
	- 하나의 게임이 여러 플렛폼에서 동작할 수 있게 해하는 것
	- 현 세대 엔진의 대부분이 지원 함

- 운영채제 Operating System - OS
	 - 시스템 하드웨어를 관리하고 각종 공용 시스템 서비스를 제공하는 시스템 소프트웨어
	 - Windows, Android, IOS, MacOS, Linux, Unix

- 컴퓨터 구조
	- 폰 노이만 구조
		- CPU => Memory

- SDK (Software Development Kit)
	- 프로그래머가 어플리케이션(응용 프로그램)을 만드는데 필요한 개발도구
	- 게임 엔진보다 좀 더 포괄적인 개념
	- 개발도구 
		- 컴파일러, 라이브러리, 디버거, 문서(메뉴얼) 등



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
11월 10일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ   
- API (Application Programing Interface)
	- 프로그램간 상호작용을 할 수 있게 도와주는 소프트웨어
	- 한 프로그램이 다른 컴퓨터나 프로그램에게 서비스를 제공하기 위해 만들어놓은 소프트웨어 인터페이스
	- DLL 파일

- 컴파일러
	- 사람이 알아볼 수 있는 고레벨 언어 Text파일을 컴퓨터가 알아볼 수 있도록  어셈블리, 기계어로 변경해주는 프로그램
	- 코드 전체를 한번에 번역, 실행속도는 인터프리터에 비해 빠르다.

	   
- 인터프리터
	- 코드를 한 줄씩 읽어 실시간 번역. 실행속도는 컴파일러에 비해 느리다.
	- Glue 언어 런타임에 코드를 수정할 수 있다.

최근에는 컴파일언어도 인터프리터기능을 지원하는 추세

- 디자인패턴
	- 소프트웨어 디자인에서 특정 문맥에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책
	- 정석, 모법답안

	- 싱글톤
		- 클래스의 객체를 하나만 생성하는 디자인패턴
		- 편하게 쓸수 있으며 유일성이 보장이 되지만 객체지향적 관점에서는 생각해봐야 함

	- 팩토리
		- 다른 클래스의 객체를 생성을 전담하는 클래스를 만드는 디자인패턴
		- 처음 생성할 때 해야할 일들이 많아지면 생성만 전담하는 코드가 분리되어있는 것이 유지보수가 쉽다.

- C#
	- C++  , JAVA 의 결합
	- 마소의 .NET이 돌아가는 곳에서 C#이 돌아감
	- 객체지향
	- 컴파일방식, 인터프리터방식 동시지원

	- 접근 제한자
		- 클래스의 멤버에 접근할 수 있는 정도를 설정하는 것
		- public, private, protected

	- Overriding
		- 상속받은 멤버함수를 재 정의 하는 것
		- 함수의 프로토타입은 변화가 없다.
		- 함수의 바디부분만 달라진다.
		
	- Overloading
		- 함수의 이름과 리턴타입은 같지만 파라미터가 다른 경우
		- 기능은 같지만 받아야할 파라미터가 다를때 사용
		




	- VisualBasic goto 문 지원



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
11월 13일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
-  virtual함수의 실행 방법
	-  virtual 키워드가 붙은 곳에 가상테이블을 만들어서 그곳에 기록된 주소로 점프하게 됨
	- 가상 함수 실행 시 기존 부모쪽의 함수로 점프를 한 다음 그곳에 기록된 곳으로 다시 점프를 하게 됨

- 메모리 영역
	- 힙 Heap 
		- 참조타입, class, 얕은 복사
	- 스텍 Stack
		- 값타입, Struct, 깊은 복사

	- 박싱
		- 값타입을 참조타입으로 캐스팅 할 때 발생. 스텍에 저장되어있던 데이터를 힙에 복사를 하면서 시간이 많이 걸리고 많은 연산이 필요하게 된다.

		- List - 제네릭타입. 유연성은 다소 떨어지지만 타입을 미리 정해줘서 박싱 언박싱이 일어나지 않는다.
		
		- ArrayList.Add(); 제네릭타입이 아닌 ArrayList는  값타입(int, float 등)을 저장하면 참조타입으로 바꿔서 저장하고 불러올때 역시 참조타입을 값타입으로 다시 바꾸는 과정이 필요하기 때문에 기산이 많이 걸린다.

	- 씬
		- 게임오브젝트
			- 컴포넌트
	- 충돌처리
		- Collider
			- OncollisionEnter, Exit
			- OnTriggerEnter, Exit
		- RigidBody

	- Transform
		- 위치, 회전, 스케일


- 최적화
	- Batch (일괄)
		- 일괄처리 횟수가 많을 수록 효율적이라 볼 수 있음
	- 정적 Static Batch, 런타임 전.
		- 움직이지 않는 오브젝트들을 한번에 모아서 렌더링
		- Lighting  도 보통 Static 이기때문에 
		- 
	- 동적 Dynamic Batch, 런타임
	- 저가형 컴퓨터에서 최적화를 위해 개발되었으나 현재 잘 쓰이지 않음



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
11월 16일
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
- 1-1
	- 소프트웨어가 구도 ㅇ가능한 하드웨어 아키텍쳐나 소프트웨어 프레임워크의 종류를 무엇이라고 하는가
		- 플렛폼

- 1-2
	- 게임용 플렛폼에는 무엇이 있는가
		- Windows, Playstation, XBOX, Android, IOS, Nintendo

- 2-1
	- 하나의게임이 여러플렛폼에서 동작할수 이게 하는것
		- 멀티플렛폼, 크로스플렛폼

- 2-2
	- 멀티플렛폼을 지원하는 게임엔진에는 어떤것이 있는가
		- 유니티, 언리얼, godot

- 3-1
	- 상속받은 클래스에서 부모클레스의 멤버를 사용하지 못하게 하려면 접근제한자를 무엇을 써야하는가
		- private
- 3-2
	- 부모클레스의 가상함수를 덮어쓰기 위해서 사용하는 키워드는?
		- override

- 4-1
	- SceneManager 클레스에 접근하기 위해 필요한 네임스페이스는 무엇인가?
		- UnitiEngine.SceneManagement;
- 4-2
	- SceneManager 클래스에서 씬을 불러오기 위해 사용하는 함수의 이름은?
		- LoadScene, LoadSceneAsync

- 5-1
	- Collider가 다른 Collider 와 충돌 후 떨어질 때 실행되는 함수의 이름은?
		- OnCollisionExit
- 5-2
	- Collider가 다른 Collider 와 충돌했을 때 실행되는 함수의 이름은?
		 - OnCollisionEnter

- 6-1
	- 오브젝트의 애니메이터 컴포넌트를 test라는 변수에 저장해라
		- Animator test = GameObject.Find("abc").GetComponent<>();

- 6-2
	- GameObject가 가지지 않은 컴포넌트를 가져오려고 시도했을 때 결과는 무엇인가?
		- null










